

---
描述：'GitHub Copilot 的迁移和代码演进指令生成器。分析两个项目版本（分支、提交或发布版本）之间的差异，以创建精确的指令，使 Copilot 在技术迁移、重大重构或框架版本升级过程中保持一致性。'
代理：'agent'
---

# 迁移和代码演进指令生成器

## 配置变量

```
${MIGRATION_TYPE="框架版本|架构重构|技术迁移|依赖更新|模式变更"}
<!-- 迁移或演进类型 -->

${SOURCE_REFERENCE="分支|提交|标签"}
<!-- 源参考点（迁移前状态） -->

${TARGET_REFERENCE="分支|提交|标签"}  
<!-- 目标参考点（迁移后状态） -->

${ANALYSIS_SCOPE="整个项目|特定文件夹|仅修改的文件"}
<!-- 分析范围 -->

${CHANGE_FOCUS="破坏性变更|新规范|过时模式|API变更|配置"}
<!-- 变更的主要方面 -->

${AUTOMATION_LEVEL="保守|平衡|激进"}
<!-- Copilot 建议的自动化级别 -->

${GENERATE_EXAMPLES="true|false"}
<!-- 是否包含转换示例 -->

${VALIDATION_REQUIRED="true|false"}
<!-- 是否需要在应用前进行验证 -->
```

## 生成的提示

```
"分析两个项目状态之间的代码演进，以生成 GitHub Copilot 的精确迁移指令。这些指令将指导 Copilot 在未来的修改中自动应用相同的转换模式。请遵循以下方法论：

### 第一阶段：对比状态分析

#### 结构变更检测
- 比较 ${SOURCE_REFERENCE} 和 ${TARGET_REFERENCE} 之间的文件夹结构
- 识别移动、重命名或删除的文件
- 分析配置文件的变更
- 记录新增的依赖项和移除的依赖项

#### 代码转换分析
${MIGRATION_TYPE == "框架版本" ? 
  "- 识别框架版本之间的 API 变更
   - 分析新功能的使用情况
   - 记录已弃用的方法/属性
   - 注意语法或规范的变更" : ""}

${MIGRATION_TYPE == "架构重构" ? 
  "- 分析架构模式的变更
   - 识别引入的新抽象概念
   - 记录职责重新分配
   - 注意数据流的变更" : ""}

${MIGRATION_TYPE == "技术迁移" ? 
  "- 分析一种技术替换为另一种技术
   - 识别功能等价性
   - 记录 API 和语法变更
   - 注意新增的依赖项和配置" : ""}

#### 转换模式提取
- 识别重复应用的转换模式
- 分析从旧格式到新格式的转换规则
- 记录例外情况和特殊情形
- 创建前后对应矩阵

### 第二阶段：迁移指令生成

创建一个 `.github/copilot-migration-instructions.md` 文件，结构如下：

```markdown
# GitHub Copilot 迁移指令

## 迁移上下文
- **类型**: ${MIGRATION_TYPE}
- **来源**: ${SOURCE_REFERENCE} 
- **目标**: ${TARGET_REFERENCE}
- **日期**: [生成日期]
- **范围**: ${ANALYSIS_SCOPE}

## 自动转换规则

### 1. 必须的转换
${AUTOMATION_LEVEL != "保守" ? 
  "[自动转换规则]
   - **旧模式**: [旧代码]
   - **新模式**: [新代码]
   - **触发条件**: 何时检测到此模式
   - **操作**: 自动应用的转换" : ""}

### 2. 需要验证的转换
${VALIDATION_REQUIRED == "true" ? 
  "[需要验证的转换]
   - **检测到的模式**: [描述]
   - **建议的转换**: [新方法]
   - **所需验证**: [验证标准]
   - **替代方案**: [替代选项]" : ""}

### 3. API 对应关系
${CHANGE_FOCUS == "API变更" || MIGRATION_TYPE == "框架版本" ? 
  "[API 对应表]
   | 旧 API   | 新 API   | 说明     | 示例        |
   | -------- | -------- | -------- | ------------ |
   | [旧 API] | [新 API] | [变更内容] | [代码示例] | " : ""} |

### 4. 需要采用的新模式
[检测到的新兴模式]
- **模式**: [模式名称]
- **使用场景**: [何时使用]
- **实现方式**: [如何实现]
- **优势**: [优点]

### 5. 需要避免的过时模式
[检测到的过时模式]
- **过时模式**: [旧模式]
- **为何避免**: [原因]
- **替代方案**: [新模式]
- **迁移步骤**: [转换步骤]

## 文件类型特定指令

${GENERATE_EXAMPLES == "true" ? 
  "### 配置文件
   [配置文件转换示例]
   
   ### 主源文件
   [主源文件转换示例]
   
   ### 测试文件
   [测试文件转换示例]" : ""}

## 验证与安全

### 自动控制点
- 每次转换后的验证
- 验证变更的测试
- 监控性能指标
- 执行兼容性检查

### 手动升级
需要人工干预的情况：
- [复杂案例列表]
- [架构决策]
- [业务影响]

## 迁移监控

### 跟踪指标
- 自动迁移的代码百分比
- 所需手动验证的数量
- 自动转换的错误率
- 每个文件的平均迁移时间

### 错误报告
如何向 Copilot 报告错误的转换：
- 改进规则的反馈模式
- 记录例外情况
- 对指令进行调整

```

### 第三阶段：上下文示例生成

${GENERATE_EXAMPLES == "true" ? 
  "#### 转换示例
   对每个识别到的模式，生成：

   ```
   // 之前 (${SOURCE_REFERENCE})
   [旧代码示例]
   
   // 之后 (${TARGET_REFERENCE}) 
   [新代码示例]
   
   // Copilot 指令
   当你看到此模式 [触发条件]，按照以下步骤将其转换为 [新模式]：[步骤]
   ```
  ：""}

### 第四阶段：验证与优化

#### 指令测试
- 在测试代码上应用指令
- 验证转换的一致性
- 根据结果调整规则
- 记录例外情况和边缘情形

#### 迭代优化  
${AUTOMATION_LEVEL == "激进" ? 
  "- 精炼规则以最大化自动化
   - 减少检测中的误报
   - 提高转换准确性
   - 记录经验教训" : ""}

### 最终结果

使 GitHub Copilot 能够：
1. **自动应用**相同的转换模式于未来的代码修改
2. **保持一致性**与新采用的规范
3. **避免过时模式**通过自动推荐替代方案
4. **加速未来迁移**通过积累经验
5. **减少错误**通过自动化重复转换

这些指令将 Copilot 转化为一个智能迁移助手，能够一致且可靠地重现您的技术演进决策。
"
```

## 典型使用场景

### 框架版本迁移
适用于记录从 Angular 14 迁移到 Angular 17、从 React 类组件迁移到 Hooks、从 .NET Framework 迁移到 .NET Core 等场景。自动识别破坏性变更并生成相应的转换规则。

### 技术栈演进
当完全替换一种技术时（如 jQuery 到 React、REST 到 GraphQL、SQL 到 NoSQL）至关重要。创建包含模式映射的全面迁移指南。

### 架构重构
适用于大型重构，如单体架构到微服务架构、MVC 到 Clean 架构、组件架构到可组合架构。为未来类似转换保留架构知识。

### 设计模式现代化
适用于采用新模式（如仓储模式、依赖注入、观察者模式到响应式编程）时。记录理由和实现差异。

## 独特优势

### 🧠 **人工智能增强**
与传统迁移文档不同，这些指令“训练”GitHub Copilot 在未来的代码修改中自动重现您的技术演进决策。

### 🔄 **知识积累**  
将特定项目经验转化为可重用的规则，避免迁移专业知识的流失，并加速未来的类似迁移。

### 🎯 **上下文感知的精确性**  
不提供通用建议，而是生成针对您特定代码库的指令，包含您项目演进中的真实前后示例。

### ⚡ **自动化一致性**  
确保新代码添加时自动遵循新规范，防止架构退化并保持代码演进的连贯性。