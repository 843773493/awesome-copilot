

---
描述：'一种全面的技术无关型提示，用于分析和记录项目文件夹结构。可自动检测项目类型（.NET、Java、React、Angular、Python、Node.js、Flutter），生成包含可视化选项、命名规范、文件放置模式以及扩展模板的详细蓝图，以保持在多种技术栈中的一致代码组织。'
代理：'代理'
---

# 项目文件夹结构蓝图生成器

## 配置变量

${PROJECT_TYPE="Auto-detect|.NET|Java|React|Angular|Python|Node.js|Flutter|Other"} 
<!-- 选择主要技术 -->

${INCLUDES_MICROSERVICES="Auto-detect|true|false"} 
<!-- 该项目是否采用微服务架构？ -->

${INCLUDES_FRONTEND="Auto-detect|true|false"} 
<!-- 项目是否包含前端组件？ -->

${IS_MONOREPO="Auto-detect|true|false"} 
<!-- 该项目是否为包含多个项目的单体仓库？ -->

${VISUALIZATION_STYLE="ASCII|Markdown List|Table"} 
<!-- 如何可视化结构 -->

${DEPTH_LEVEL=1-5} 
<!-- 需要详细记录多少层级的文件夹 -->

${INCLUDE_FILE_COUNTS=true|false} 
<!-- 是否包含文件数量统计 -->

${INCLUDE_GENERATED_FOLDERS=true|false} 
<!-- 是否包含自动生成的文件夹 -->

${INCLUDE_FILE_PATTERNS=true|false} 
<!-- 是否记录文件命名/位置模式 -->

${INCLUDE_TEMPLATES=true|false} 
<!-- 是否包含新功能的文件/文件夹模板 -->

## 生成提示

"分析项目的文件夹结构，创建一份名为 'Project_Folders_Structure_Blueprint.md' 的全面文档，作为维护一致代码组织的权威指南。使用以下方法：

### 1. 初始自动检测阶段

${PROJECT_TYPE == "Auto-detect" ? 
"首先扫描文件夹结构以识别关键文件，确定项目类型：
- 查找解决方案/项目文件（.sln, .csproj, .fsproj, .vbproj）以识别 .NET 项目
- 检查构建文件（pom.xml, build.gradle, settings.gradle）以识别 Java 项目
- 识别包含依赖项的 package.json 以确定 JavaScript/TypeScript 项目
- 查找特定框架文件（angular.json, react-scripts 入口文件, next.config.js）
- 检查 Python 项目标识符（requirements.txt, setup.py, pyproject.toml）
- 分析移动应用标识符（pubspec.yaml, android/ios 文件夹）
- 记录所有发现的技术标识及其版本" : 
"专注于 ${PROJECT_TYPE} 项目的结构分析"}

${IS_MONOREPO == "Auto-detect" ? 
"通过以下特征判断是否为单体仓库：
- 存在多个独立项目及其各自的配置文件
- 工作区配置文件（lerna.json, nx.json, turborepo.json 等）
- 跨项目引用和共享依赖模式
- 根目录的编排脚本和配置" : ""}

${INCLUDES_MICROSERVICES == "Auto-detect" ? 
"检查微服务架构的标识：
- 多个服务目录具有相似/重复的结构
- 服务特定的 Dockerfile 或部署配置
- 服务间通信模式（API、消息代理）
- 服务注册或发现配置
- API 网关配置文件
- 服务间共享的库或工具" : ""}

${INCLUDES_FRONTEND == "Auto-detect" ? 
"通过以下特征识别前端组件：
- Web 资源目录（wwwroot, public, dist, static）
- UI 框架文件（组件、模块、页面）
- 前端构建配置（webpack, vite, rollup 等）
- 样式表组织（CSS, SCSS, styled-components）
- 静态资源组织（图片、字体、图标）" : ""}

### 2. 结构概览

提供 ${PROJECT_TYPE == "Auto-detect" ? "检测到的项目类型" : PROJECT_TYPE} 项目的高层次组织原则和文件夹结构概览：

- 记录文件夹结构反映的整体架构方法
- 识别主要的组织原则（按功能、按层、按领域等）
- 注意代码库中重复出现的结构模式
- 记录可推断的结构设计理由

${IS_MONOREPO == "Auto-detect" ? 
"如果检测到是单体仓库，请解释其组织方式及项目间关系。" : 
IS_MONOREPO ? "解释单体仓库的组织方式及项目间关系。" : ""}

${INCLUDES_MICROSERVICES == "Auto-detect" ? 
"如果检测到微服务，请描述其结构和组织方式。" : 
INCLUDES_MICROSERVICES ? "描述微服务的结构和组织方式。" : ""}

### 3. 目录可视化

${VISUALIZATION_STYLE == "ASCII" ? 
"创建一个深度为 ${DEPTH_LEVEL} 层的 ASCII 树状结构表示。" : ""}

${VISUALIZATION_STYLE == "Markdown List" ? 
"使用嵌套的 Markdown 列表表示深度为 ${DEPTH_LEVEL} 层的文件夹结构。" : ""}

${VISUALIZATION_STYLE == "Table" ? 
"创建一个包含路径、用途、内容类型和规范的表格。" : ""}

${INCLUDE_GENERATED_FOLDERS ? 
"包含所有文件夹，包括自动生成的文件夹。" : 
"排除自动生成的文件夹（如 bin/、obj/、node_modules/ 等）。"}

### 4. 关键目录分析

记录每个重要目录的用途、内容和模式：

${PROJECT_TYPE == "Auto-detect" ? 
"对于每个检测到的技术，基于观察到的使用模式分析目录结构：" : ""}

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "Auto-detect") ? 
"#### .NET 项目结构（如果检测到）

- **解决方案组织**：
  - 项目分组和关联方式
  - 解决方案文件夹组织模式
  - 多目标项目模式

- **项目组织**：
  - 内部文件夹结构模式
  - 源代码组织方式
  - 资源组织
  - 项目依赖和引用

- **领域/功能组织**：
  - 业务领域或功能如何分离
  - 领域边界执行模式

- **分层组织**：
  - 分离关注点（控制器、服务、仓库等）
  - 层间交互和依赖模式

- **配置管理**：
  - 配置文件位置和用途
  - 环境特定配置
  - 密钥管理方法

- **测试项目组织**：
  - 测试项目结构和命名
  - 测试分类和组织方式
  - 测试数据和模拟文件位置" : ""}

${(PROJECT_TYPE == "React" || PROJECT_TYPE == "Angular" || PROJECT_TYPE == "Auto-detect") ? 
"#### UI 项目结构（如果检测到）

- **组件组织**：
  - 组件文件夹结构模式
  - 分组策略（按功能、类型等）
  - 公共组件与功能特定组件

- **状态管理**：
  - 与状态相关的文件组织
  - 全局状态存储结构
  - 本地状态管理模式

- **路由组织**：
  - 路由定义位置
  - 页面/视图组件组织
  - 路由参数处理

- **API 集成**：
  - API 客户端组织
  - 服务层结构
  - 数据获取模式

- **资源管理**：
  - 静态资源组织
  - 图像/媒体文件结构
  - 字体和图标组织

- **样式组织**：
  - CSS/SCSS 文件结构
  - 主题组织
  - 样式模块模式" : ""}

### 5. 文件放置模式

${INCLUDE_FILE_PATTERNS ? 
"记录决定不同类型文件放置位置的模式：

- **配置文件**：
  - 不同类型配置文件的位置
  - 环境特定配置模式

- **模型/实体定义**：
  - 领域模型定义位置
  - 数据传输对象（DTO）位置
  - 模式定义位置

- **业务逻辑**：
  - 服务实现位置
  - 业务规则组织
  - 工具函数和辅助函数放置位置

- **接口定义**：
  - 接口和抽象类定义位置
  - 接口分组和组织方式

- **测试文件**：
  - 单元测试位置模式
  - 集成测试放置位置
  - 测试工具和模拟文件位置

- **文档文件**：
  - API 文档放置位置
  - 内部文档组织方式
  - README 文件分布" : 
"记录项目中关键文件类型的位置。"}

### 6. 命名和组织规范
记录项目中观察到的命名和组织规范：

- **文件命名模式**：
  - 大小写规范（PascalCase、camelCase、kebab-case）
  - 前缀和后缀模式
  - 文件名中的类型指示符

- **文件夹命名模式**：
  - 不同类型文件夹的命名规范
  - 分层命名模式
  - 分组和分类规范

- **命名空间/模块模式**：
  - 命名空间/模块如何映射到文件夹结构
  - 导入/使用语句组织
  - 内部 API 与公共 API 的分离

- **组织模式**：
  - 代码共置策略
  - 功能封装方法
  - 横切关注点组织

### 7. 导航和开发工作流
提供关于如何导航和操作代码库结构的指导：

- **入口点**：
  - 主应用程序入口点
  - 关键配置起点
  - 理解项目的初始文件

- **常见开发任务**：
  - 新功能添加位置
  - 现有功能扩展方式
  - 新测试放置位置
  - 配置修改位置

- **依赖模式**：
  - 文件夹间的依赖流动方式
  - 导入/引用模式
  - 依赖注入注册位置

${INCLUDE_FILE_COUNTS ? 
"- **内容统计**：
  - 每个目录的文件数量分析
  - 代码分布指标
  - 复杂度集中区域" : ""}

### 8. 构建和输出组织
记录构建过程和输出组织方式：

- **构建配置**：
  - 构建脚本的位置和用途
  - 构建流水线组织
  - 构建任务定义

- **输出结构**：
  - 编译/构建输出位置
  - 输出组织模式
  - 分发包结构

- **环境特定构建**：
  - 开发与生产环境的差异
  - 环境配置策略
  - 构建变体组织

### 9. 扩展和演进
记录项目结构如何设计以支持扩展：

- **扩展点**：
  - 如何在保持规范的前提下添加新模块/功能
  - 插件/扩展文件夹模式
  - 自定义目录结构

- **可扩展性模式**：
  - 结构如何扩展以支持更大的功能
  - 分解大型模块的方法
  - 代码分割策略

- **重构模式**：
  - 观察到的常见重构方法
  - 结构变更的管理方式
  - 逐步重组模式

${INCLUDE_TEMPLATES ? 
"### 10. 结构模板

提供遵循项目规范创建新组件的模板：

- **新功能模板**：
  - 添加完整功能的文件夹结构
  - 所需文件类型及其位置
  - 需遵循的命名模式

- **新组件模板**：
  - 典型组件的目录结构
  - 必须包含的文件
  - 与现有结构的集成点

- **新服务模板**：
  - 添加新服务的结构
  - 接口和实现放置位置
  - 配置和注册模式

- **新测试结构**：
  - 测试项目/文件的文件夹结构
  - 测试文件组织模板
  - 测试资源组织" : ""}

### ${INCLUDE_TEMPLATES ? "11" : "10"}. 结构强制执行
记录项目结构如何维护和强制执行：

- **结构验证**：
  - 强制执行结构的工具/脚本
  - 构建检查以确保结构合规
  - 与结构相关的代码规范

- **文档实践**：
  - 结构变更的文档方式
  - 架构决策的记录位置
  - 结构演进历史

在文档末尾添加一个关于维护此蓝图以及最后更新时间的章节。
"