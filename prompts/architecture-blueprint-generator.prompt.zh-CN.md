---
描述：'一个全面的项目架构蓝图生成器，通过分析代码库创建详细的架构文档。能够自动检测技术栈和架构模式，生成可视化图表，记录实现模式，并提供可扩展的蓝图以保持架构一致性并指导新开发。'
代理：'代理'
---

# 全面的项目架构蓝图生成器

## 配置变量

${PROJECT_TYPE="自动检测|.NET|Java|React|Angular|Python|Node.js|Flutter|其他"} <!-- 主要技术 -->
${ARCHITECTURE_PATTERN="自动检测|Clean Architecture|微服务|分层|MVVM|MVC|Hexagonal|事件驱动|无服务器|单体|其他"} <!-- 主要架构模式 -->
${DIAGRAM_TYPE="C4|UML|流程|组件|无"} <!-- 架构图类型 -->
${DETAIL_LEVEL="高层次|详细|全面|可实施"} <!-- 包含的详细程度 -->
${INCLUDES_CODE_EXAMPLES=true|false} <!-- 是否包含示例代码以说明模式 -->
${INCLUDES_IMPLEMENTATION_PATTERNS=true|false} <!-- 是否包含详细实现模式 -->
${INCLUDES_DECISION_RECORDS=true|false} <!-- 是否包含架构决策记录 -->
${FOCUS_ON_EXTENSIBILITY=true|false} <!-- 是否强调扩展点和模式 -->

## 生成提示

"创建一个全面的 'Project_Architecture_Blueprint.md' 文档，彻底分析代码库中的架构模式，作为维护架构一致性的权威参考。使用以下方法：

### 1. 架构检测与分析

- ${PROJECT_TYPE == "自动检测" ? "通过分析以下内容识别所有技术栈和框架：
  - 项目和配置文件
  - 包依赖关系和导入语句
  - 框架特定的模式和约定
  - 构建和部署配置" : "专注于 ${PROJECT_TYPE} 特定的模式和实践"}

- ${ARCHITECTURE_PATTERN == "自动检测" ? "通过分析以下内容确定架构模式：
  - 文件夹组织和命名空间
  - 依赖关系流和组件边界
  - 接口隔离和抽象模式
  - 组件间通信机制" : "记录 ${ARCHITECTURE_PATTERN} 架构的实现方式"}

### 2. 架构概览

- 提供清晰简洁的总体架构方法说明
- 记录架构选择中体现的指导原则
- 识别架构边界及其强制执行方式
- 注明任何混合架构模式或标准模式的变体

### 3. 架构可视化

${DIAGRAM_TYPE != "无" ? `创建 ${DIAGRAM_TYPE} 图表，涵盖多个抽象层次：

- 高层次架构概览，展示主要子系统
- 组件交互图表，显示关系和依赖
- 数据流图表，说明信息在系统中的流动
- 确保图表准确反映实际实现，而非理论模式` : "基于实际代码依赖关系描述组件关系，提供清晰的文本解释：
- 子系统组织和边界
- 依赖方向和组件交互
- 数据流和处理序列"}

### 4. 核心架构组件

对于代码库中发现的每个架构组件：

- **目的与职责**：
  - 在架构中的主要功能
  - 所解决的业务领域或技术关注点
  - 边界和范围限制

- **内部结构**：
  - 组件内类/模块的组织方式
  - 关键抽象及其实现
  - 使用的设计模式

- **交互模式**：
  - 组件如何与其他组件通信
  - 暴露和消费的接口
  - 依赖注入模式
  - 事件发布/订阅机制

- **演进模式**：
  - 组件如何扩展
  - 变化点和插件机制
  - 配置和自定义方法

### 5. 架构分层与依赖关系

- 映射代码库中实现的分层结构
- 记录各层之间的依赖规则
- 识别实现分层分离的抽象机制
- 注明任何循环依赖或分层违规
- 记录用于保持分层分离的依赖注入模式

### 6. 数据架构

- 记录领域模型结构和组织方式
- 映射实体关系和聚合模式
- 识别数据访问模式（仓库、数据映射器等）
- 记录数据转换和映射方法
- 注明缓存策略和实现
- 记录数据验证模式

### 7. 横切关注点实现

记录横切关注点的实现模式：

- **认证与授权**：
  - 安全模型的实现
  - 权限强制执行模式
  - 身份管理方法
  - 安全边界模式

- **错误处理与韧性**：
  - 异常处理模式
  - 重试和断路器实现
  - 回退和优雅降级策略
  - 错误报告和监控方法

- **日志与监控**：
  - 仪器化模式
  - 可观测性实现
  - 诊断信息流
  - 性能监控方法

- **验证**：
  - 输入验证策略
  - 业务规则验证实现
  - 验证职责分配
  - 错误报告模式

- **配置管理**：
  - 配置来源模式
  - 环境特定配置策略
  - 密钥管理方法
  - 功能标志实现

### 8. 服务通信模式

- 记录服务边界定义
- 识别通信协议和格式
- 映射同步与异步通信模式
- 记录 API 版本控制策略
- 识别服务发现机制
- 注明服务通信中的韧性模式

### 9. 技术特定架构模式

${PROJECT_TYPE == "自动检测" ? "对于每个检测到的技术栈，记录其特定的架构模式：" : `记录 ${PROJECT_TYPE} 特定的架构模式：`}

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自动检测") ?
"#### .NET 架构模式（如检测到）

- 主机和应用模型实现
- 中间件管道组织
- 框架服务集成模式
- ORM 和数据访问方法
- API 实现模式（控制器、最小 API 等）
- 依赖注入容器配置" : ""}

${(PROJECT_TYPE == "Java" || PROJECT_TYPE == "自动检测") ?
"#### Java 架构模式（如检测到）

- 应用容器和启动过程
- 依赖注入框架使用（Spring、CDI 等）
- AOP 实现模式
- 事务边界管理
- ORM 配置和使用模式
- 服务实现模式" : ""}

${(PROJECT_TYPE == "React" || PROJECT_TYPE == "自动检测") ?
"#### React 架构模式（如检测到）

- 组件组合和重用策略
- 状态管理架构
- 副作用处理模式
- 路由和导航方法
- 数据获取和缓存模式
- 渲染优化策略" : ""}

${(PROJECT_TYPE == "Angular" || PROJECT_TYPE == "自动检测") ?
"#### Angular 架构模式（如检测到）

- 模块组织策略
- 组件层级设计
- 服务和依赖注入模式
- 状态管理方法
- 反应式编程模式
- 路由守卫实现" : ""}

${(PROJECT_TYPE == "Python" || PROJECT_TYPE == "自动检测") ?
"#### Python 架构模式（如检测到）

- 模块组织方法
- 依赖管理策略
- 面向对象 vs. 函数式实现模式
- 框架集成模式
- 异步编程方法" : ""}

### 10. 实现模式

${INCLUDES_IMPLEMENTATION_PATTERNS ?
"记录关键架构组件的具体实现模式：

- **接口设计模式**：
  - 接口隔离方法
  - 抽象层级决策
  - 通用 vs. 特定接口模式
  - 默认实现模式

- **服务实现模式**：
  - 服务生命周期管理
  - 服务组合模式
  - 操作实现模板
  - 服务内的错误处理

- **仓库实现模式**：
  - 查询模式实现
  - 事务管理
  - 并发处理
  - 批量操作模式

- **控制器/API 实现模式**：
  - 请求处理模式
  - 响应格式化方法
  - 参数验证
  - API 版本控制实现

- **领域模型实现**：
  - 实体实现模式
  - 值对象模式
  - 领域事件实现
  - 业务规则强制执行" : "提及详细实现模式在代码库中有所不同。"}

### 11. 测试架构

- 记录与架构对齐的测试策略
- 识别测试边界模式（单元、集成、系统）
- 映射测试替身和模拟方法
- 记录测试数据策略
- 注明测试工具和框架集成

### 12. 部署架构

- 记录从配置推导出的部署拓扑
- 识别环境特定的架构调整
- 映射运行时依赖解析模式
- 记录跨环境的配置管理
- 识别容器化和编排方法
- 注明云服务集成模式

### 13. 扩展与演进模式

${FOCUS_ON_EXTENSIBILITY ?
"提供扩展架构的详细指导：

- **功能添加模式**：
  - 如何在保持架构完整性的情况下添加新功能
  - 按类型放置新组件的位置
  - 依赖引入指南
  - 配置驱动的扩展模式

- **修改模式**：
  - 如何安全地修改现有组件
  - 维护向后兼容性的策略
  - 废弃模式
  - 迁移方法

- **集成模式**：
  - 如何集成新外部系统
  - 适配器实现模式
  - 反腐层模式
  - 服务门面实现" : "记录架构中的关键扩展点。"}

${INCLUDES_CODE_EXAMPLES ?
"### 14. 架构模式示例
提取能说明关键架构模式的代表性代码示例：

- **分层分离示例**：
  - 接口定义与实现分离
  - 跨层通信模式
  - 依赖注入示例

- **组件通信示例**：
  - 服务调用模式
  - 事件发布与处理
  - 消息传递实现

- **扩展点示例**：
  - 插件注册与发现
  - 扩展接口实现
  - 配置驱动的扩展模式

每个示例需包含足够的上下文以清晰展示模式，但保持示例简洁，聚焦于架构概念。" : ""}

${INCLUDES_DECISION_RECORDS ?
"### 15. 架构决策记录
记录代码库中显而易见的关键架构决策：

- **架构风格决策**：
  - 为何选择当前架构模式
  - 考虑的替代方案（基于代码演进）
  - 影响决策的约束条件

- **技术选择决策**：
  - 关键技术选择及其架构影响
  - 框架选择的依据
  - 自定义 vs. 现成组件的决策

- **实现方法决策**：
  - 选择的具体实现模式
  - 标准模式的调整
  - 性能 vs. 可维护性的权衡

对每个决策，需注明：

- 促使决策的上下文
- 决策时考虑的因素
- 导致的结果（正面和负面）
- 引入的未来灵活性或限制" : ""}

### ${INCLUDES_DECISION_RECORDS ? "16" : INCLUDES_CODE_EXAMPLES ? "15" : "14"}. 架构治理

- 记录如何维护架构一致性
- 识别用于架构合规性的自动化检查
- 注明代码库中显而易见的架构评审流程
- 记录架构文档实践

### ${INCLUDES_DECISION_RECORDS ? "17" : INCLUDES_CODE_EXAMPLES ? "16" : "15"}. 新开发蓝图

创建一个清晰的架构指南用于实施新功能：

- **开发流程**：
  - 不同功能类型的起始点
  - 组件创建顺序
  - 与现有架构的集成步骤
  - 按架构层级的测试方法

- **实现模板**：
  - 关键架构组件的基础类/接口模板
  - 新组件的标准文件组织
  - 依赖声明模式
  - 文档要求

- **常见陷阱**：
  - 需要避免的架构违规
  - 常见架构错误
  - 性能考虑
  - 测试盲点

包含该蓝图生成的时间信息，并推荐如何随着架构演进而更新该文档。"
