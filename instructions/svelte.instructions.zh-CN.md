

---
description: 'Svelte 5 和 SvelteKit 的开发标准与最佳实践，用于构建基于组件的用户界面和全栈应用'
applyTo: '**/*.svelte, **/*.ts, **/*.js, **/*.css, **/*.scss, **/*.json'
---

# Svelte 5 和 SvelteKit 开发指南

构建高质量 Svelte 5 和 SvelteKit 应用的指南，涵盖现代基于 runes 的响应式编程、TypeScript 以及性能优化。

## 项目背景
- 使用 Svelte 5.x 及其 runes 系统（$state, $derived, $effect, $props, $bindable）
- 使用 SvelteKit 构建全栈应用，采用基于文件的路由系统
- 使用 TypeScript 实现类型安全和更好的开发体验
- 组件作用域样式，使用 CSS 自定义属性
- 采用渐进增强和以性能为导向的开发方法
- 现代构建工具（Vite）及优化方案

## 开发规范

### 架构
- 使用 Svelte 5 的 runes 系统进行所有响应式编程，而非传统存储
- 按功能或领域组织组件以实现可扩展性
- 将展示组件与逻辑密集型组件分离
- 将可复用的逻辑提取为组合函数
- 使用插槽和片段实现组件的合理组合
- 使用 SvelteKit 的基于文件的路由系统并配置适当的加载函数

### TypeScript 集成
- 在 `tsconfig.json` 中启用严格模式以实现最大类型安全
- 使用 `$props()` 语法定义组件属性接口
- 为事件处理、引用和 SvelteKit 生成的类型进行类型标注
- 为可复用组件使用泛型类型
- 利用 SvelteKit 生成的 `$types.ts` 文件
- 使用 `svelte-check` 实现严格的类型检查

### 组件设计
- 遵循单一职责原则设计组件
- 使用 `<script lang="ts">` 和 runes 语法作为默认设置
- 保持组件小巧且专注于单一功能
- 使用 TypeScript 实现组件属性验证
- 使用插槽和片段实现灵活的组件组合
- 设计可测试且可复用的组件

### Svelte 5 Runes 系统
- 使用 `$state()` 管理本地响应式状态
- 使用 `$derived()` 实现计算值和昂贵计算
- 使用 `$effect()` 处理副作用并确保清理
- 使用 `$props()` 定义组件属性并解构
- 使用 `$bindable()` 实现组件间的双向数据绑定
- 将传统存储迁移至 runes 以提升性能

### 状态管理
- 使用 `$state()` 管理组件本地状态
- 使用 `setContext`/`getContext` 实现上下文 API 共享状态
- 在需要时使用 SvelteKit 存储管理全局应用状态
- 对复杂数据结构保持状态规范化
- 使用派生状态处理计算值
- 实现客户端数据的适当状态持久化

### SvelteKit 模式
- 使用 `+page.svelte` 创建具有适当 SEO 的页面组件
- 使用 `+layout.svelte` 实现共享布局和导航
- 使用 `+page.server.ts` 处理服务器端数据加载和 API 调用
- 在 `+page.server.ts` 中实现表单操作以处理数据变更
- 使用 `+server.ts` 创建 API 端点和服务器端逻辑
- 使用 SvelteKit 的基于文件的系统处理路由

### 样式设计
- 使用组件作用域样式和 `<style>` 块
- 实现 CSS 自定义属性以支持主题和设计系统
- 使用 `class:` 指令实现条件样式
- 遵循 BEM 或实用优先的 CSS 习惯
- 采用移动优先策略实现响应式设计
- 适度使用 `:global()` 实现真正全局的样式

### 性能优化
- 使用带键的 `{#each}` 块实现高效列表渲染
- 使用动态导入和 `svelte:component` 实现懒加载
- 使用 `$derived()` 处理昂贵计算以避免不必要的重新计算
- 利用 SvelteKit 的自动代码分割和预加载功能
- 使用树摇和规范导入优化包体积
- 使用 Svelte DevTools 进行性能分析以识别瓶颈

### 数据获取
- 使用 SvelteKit 的加载函数进行服务器端和通用数据获取
- 实现加载、错误和成功状态
- 在服务器加载函数中使用 Promise 处理流数据
- 使用 `invalidate()` 和 `invalidateAll()` 管理缓存
- 实现乐观更新以提升用户体验
- 优雅处理离线场景和网络错误

### 错误处理
- 使用 `+error.svelte` 页面实现路由级别的错误边界
- 在加载函数和表单操作中使用 try/catch 块
- 提供有意义的错误信息和备用 UI
- 适当记录错误以用于调试和监控
- 在表单中处理验证错误并提供用户反馈
- 使用 SvelteKit 的错误和重定向辅助函数

### 表单与验证
- 使用 SvelteKit 的表单操作处理服务器端表单
- 使用 `use:enhance` 实现渐进增强
- 使用 `bind:value` 实现受控表单输入
- 在客户端和服务器端均验证数据
- 处理文件上传和复杂表单场景
- 通过标签和 ARIA 属性实现适当的可访问性

### 测试
- 使用 Vitest 和 Testing Library 为组件编写单元测试
- 测试组件行为而非实现细节
- 使用 Playwright 进行用户工作流的端到端测试
- 适当模拟 SvelteKit 的加载函数和存储
- 彻底测试表单操作和 API 端点
- 使用 axe-core 实现可访问性测试

### 安全性
- 清洗用户输入以防止 XSS 攻击
- 小心使用 `@html` 指令并验证 HTML 内容
- 使用 SvelteKit 实现适当的 CSRF 防护
- 在加载函数和表单操作中验证和清洗数据
- 使用 HTTPS 进行所有外部 API 调用和生产部署
- 使用适当的会话管理安全存储敏感数据

### 可访问性
- 使用语义化 HTML 元素和正确的标题层级
- 为所有交互元素实现键盘导航
- 提供适当的 ARIA 标签和描述
- 确保颜色对比度符合 WCAG 指南
- 使用屏幕阅读器和可访问性工具进行测试
- 为动态内容实现焦点管理

## 实现流程
1. 使用 TypeScript 和所需适配器初始化 SvelteKit 项目
2. 建立项目结构并合理组织文件夹
3. 定义 TypeScript 接口和组件属性
4. 使用 Svelte 5 的 runes 实现核心组件
5. 使用 SvelteKit 实现路由、布局和导航
6. 实现数据加载和表单处理
7. 使用自定义属性和响应式设计添加样式系统
8. 实现错误处理和加载状态
9. 添加全面的测试覆盖
10. 优化性能和包体积
11. 确保符合可访问性标准
12. 使用适当的 SvelteKit 适配器进行部署

## 其他指南
- 遵循 Svelte 的命名规范（组件使用 PascalCase，函数使用 camelCase）
- 使用 ESLint（配合 eslint-plugin-svelte）和 Prettier 保持代码一致性
- 保持依赖项更新并审计安全漏洞
- 使用 JSDoc 文档化复杂组件和逻辑
- 使用 Svelte DevTools 进行调试和性能分析
- 使用 SvelteKit 的元标签和结构化数据实现适当的 SEO
- 使用环境变量在不同部署阶段配置应用

## 常见模式
- 使用插槽实现无渲染组件以支持灵活的 UI 组合
- 使用自定义指令处理跨切面关注点和 DOM 操作
- 使用片段式组合实现可复用的模板逻辑
- 使用上下文提供者管理应用范围的状态
- 对表单和交互功能实现渐进增强
- 使用服务器端渲染和客户端水合实现最佳性能