

---
applyTo: '**'
---

# Next.js 构建大型语言模型的最佳实践（2025）

_最后更新时间：2025年7月_

本文总结了构建、组织和维护 Next.js 应用程序的最新、权威最佳实践。它旨在供大型语言模型和开发者使用，以确保代码质量、可维护性和可扩展性。

---

## 1. 项目结构与组织

- **使用 `app/` 目录**（App 路由器）创建所有新项目。优先选择它而不是传统的 `pages/` 目录。
- **顶级文件夹：**
  - `app/` — 路由、布局、页面和路由处理程序
  - `public/` — 静态资源（图片、字体等）
  - `lib/` — 公共工具、API 客户端和逻辑
  - `components/` — 可重用的 UI 组件
  - `contexts/` — React 上下文提供者
  - `styles/` — 全局和模块化样式表
  - `hooks/` — 自定义 React 钩子
  - `types/` — TypeScript 类型定义
- **共置：** 将文件（组件、样式、测试）放置在它们被使用的位置附近，但避免过于嵌套的结构。
- **路由分组：** 使用括号（例如 `(admin)`）来分组路由，而不会影响 URL 路径。
- **私有文件夹：** 以 `_` 开头（例如 `_internal`）以排除路由并表示实现细节。

- **功能文件夹：** 对于大型应用，按功能分组（例如 `app/dashboard/`、`app/auth/`）。
- **使用 `src/`**（可选）：将所有源代码放在 `src/` 中，以与配置文件分离。

## 2.1. 服务器和客户端组件集成（App 路由器）

**永远不要在服务器组件中使用 `next/dynamic` 并设置 `{ ssr: false }`。** 这是不被支持的，会导致构建或运行时错误。

**正确方法：**
- 如果你需要在服务器组件中使用客户端组件（例如使用钩子、浏览器 API 或客户端专用库的组件），必须：
  1. 将所有客户端专用的逻辑/UI 移动到一个专用的客户端组件中（在文件顶部添加 `'use client'`）。
  2. 在服务器组件中直接导入并使用该客户端组件（不需要 `next/dynamic`）。
  3. 如果你需要组合多个客户端专用元素（例如带有个人资料下拉菜单的导航栏），创建一个包含所有这些元素的单一客户端组件。

**示例：**

```tsx
// 服务器组件
import DashboardNavbar from '@/components/DashboardNavbar';

export default async function DashboardPage() {
  // ...服务器逻辑...
  return (
    <>
      <DashboardNavbar /> {/* 这是一个客户端组件 */}
      {/* ...其余服务器渲染页面内容... */}
    </>
  );
}
```

**原因：**
- 服务器组件无法使用客户端专用功能或禁用 SSR 的动态导入。
- 客户端组件可以在服务器组件中渲染，但反过来则不行。

**总结：**
始终将客户端专用 UI 移动到客户端组件中，并在你的服务器组件中直接导入。永远不要在服务器组件中使用 `next/dynamic` 并设置 `{ ssr: false }`。

---

## 2. 组件最佳实践

- **组件类型：**
  - **服务器组件**（默认）：用于数据获取、复杂逻辑和非交互式 UI。
  - **客户端组件**：在文件顶部添加 `'use client'`。用于交互性、状态或浏览器 API。
- **何时创建组件：**
  - 如果 UI 模式被重复使用超过一次。
  - 如果页面的某部分较为复杂或自包含。
  - 如果它能提高可读性或可测试性。
- **命名规范：**
  - 使用 `PascalCase` 命名组件文件和导出（例如 `UserCard.tsx`）。
  - 使用 `camelCase` 命名钩子（例如 `useUser.ts`）。
  - 使用 `snake_case` 或 `kebab-case` 命名静态资源（例如 `logo_dark.svg`）。
  - 将上下文提供者命名为 `XyzProvider`（例如 `ThemeProvider`）。
- **文件命名：**
  - 组件名称应与文件名匹配。
  - 对于单导出文件，默认导出组件。
  - 对于多个相关组件，使用 `index.ts` 作为 barrel 文件。
- **组件位置：**
  - 将共享组件放在 `components/` 目录中。
  - 将与特定路由相关的组件放在对应的路由文件夹内。
- **属性（Props）：**
  - 使用 TypeScript 接口定义属性。
  - 更倾向于显式属性类型和默认值。
- **测试：**
  - 将测试与组件共置（例如 `UserCard.test.tsx`）。

## 3. 命名规范（通用）

- **文件夹：** `kebab-case`（例如 `user-profile/`）
- **文件：** 组件使用 `PascalCase`，工具/钩子使用 `camelCase`，静态资源使用 `kebab-case`
- **变量/函数：** `camelCase`
- **类型/接口：** `PascalCase`
- **常量：** `UPPER_SNAKE_CASE`

## 4. API 路由（路由处理程序）

- **除非你需要超低延迟或地理分布，否则优先使用 API 路由而不是 Edge 函数。**
- **位置：** 将 API 路由放在 `app/api/` 目录中（例如 `app/api/users/route.ts`）。
- **HTTP 方法：** 导出以 HTTP 动词命名的异步函数（如 `GET`、`POST` 等）。
- **请求/响应：** 使用 Web 的 `Request` 和 `Response` API。如需高级功能，使用 `NextRequest`/`NextResponse`。
- **动态段：** 使用 `[param]` 定义动态 API 路由（例如 `app/api/users/[id]/route.ts`）。
- **验证：** 始终验证和清理输入。可以使用如 `zod` 或 `yup` 这样的库。
- **错误处理：** 返回适当的 HTTP 状态码和错误信息。
- **认证：** 使用中间件或服务器端会话检查保护敏感路由。

## 5. 通用最佳实践

- **TypeScript：** 使用 TypeScript 编写所有代码。在 `tsconfig.json` 中启用 `strict` 模式。
- **ESLint & Prettier：** 强制执行代码风格和代码规范。使用官方的 Next.js ESLint 配置。
- **环境变量：** 将密钥存储在 `.env.local` 中。从版本控制中永远不要提交密钥。
- **测试：** 使用 Jest、React Testing Library 或 Playwright。为所有关键逻辑和组件编写测试。
- **可访问性：** 使用语义 HTML 和 ARIA 属性。使用屏幕阅读器进行测试。
- **性能：**
  - 使用内置的图片和字体优化。
  - 使用 Suspense 和加载状态处理异步数据。
  - 避免大型客户端包；将大部分逻辑保留在服务器组件中。
- **安全性：**
  - 清理所有用户输入。
  - 生产环境中使用 HTTPS。
  - 设置安全的 HTTP 头。
- **文档：**
  - 编写清晰的 README 和代码注释。
  - 文档公开的 API 和组件。

# 避免不必要的示例文件

除非用户明确要求实时示例、Storybook 故事或显式文档组件，否则不要在主代码库中创建示例/演示文件（如 ModalExample.tsx）。默认情况下，保持仓库整洁和面向生产环境。

# 始终使用最新文档和指南
- 对于每个与 nextjs 相关的请求，首先查找最新的 nextjs 文档、指南和示例。
- 如果有可用工具，使用以下工具获取和搜索文档：
  - `resolve_library_id` 用于解析文档中的包/库名称。
  - `get_library_docs` 用于获取最新的文档。