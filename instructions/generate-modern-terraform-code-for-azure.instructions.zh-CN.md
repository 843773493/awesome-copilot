

---
description: '生成现代 Azure Terraform 代码的指南'
applyTo: '**/*.tf'
---

## 1. 使用最新版 Terraform 和提供者
始终针对最新的稳定版 Terraform 和 Azure 提供者。在代码中指定所需的 Terraform 和提供者版本以强制执行此要求。保持提供者版本更新以获取新功能和修复。

## 2. 清晰组织代码
以逻辑文件分离的方式结构化 Terraform 配置：

- 使用 `main.tf` 定义资源
- 使用 `variables.tf` 定义输入参数
- 使用 `outputs.tf` 定义输出结果
- 遵循一致的命名规范和格式化规则 (`terraform fmt`)

这使代码更易于导航和维护。

## 3. 将资源封装在模块中

使用 Terraform 模块将可重用的基础设施组件分组。对于任何将在多个上下文中使用的资源集合：

- 创建具有自身变量/输出的模块
- 通过引用模块而非复制代码来使用它
- 这有助于重用和保持一致性

## 4. 利用变量和输出

- **使用变量对所有可配置值进行参数化**，并为变量添加类型和描述信息
- **为可选变量提供默认值**以确保灵活性
- **使用输出**来暴露关键资源属性，供其他模块或用户参考
- **根据情况标记敏感值**以保护机密信息

## 5. 提供者选择 (AzureRM vs AzAPI)

- **使用 `azurerm` 提供者**处理大多数场景 – 它提供高稳定性并覆盖 Azure 的大部分服务
- **仅在需要以下功能时使用 `azapi` 提供者**：
  - 最新的 Azure 功能
  - `azurerm` 尚未支持的资源
- **在代码注释中记录选择依据**
- 如果需要，两者可以一起使用，但在不确定时优先选择 `azurerm`

## 6. 最小化依赖项

- **未经确认不要引入超出项目范围的额外提供者或模块**
- 如果需要特殊提供者（例如 `random`、`tls`）或外部模块：
  - 添加注释说明原因
  - 确保用户批准
- 保持基础设施堆栈简洁，避免不必要的复杂性

## 7. 确保幂等性

- 编写可重复应用且结果一致的配置
- **避免非幂等操作**：
  - 每次应用都会运行的脚本
  - 可能因重复创建而产生冲突的资源
- **通过多次运行 `terraform apply` 进行测试**，并确保第二次运行无任何变更
- 使用资源生命周期设置或条件表达式，以优雅处理漂移或外部变更

## 8. 状态管理

- **使用远程后端**（如 Azure 存储配合状态锁定）安全存储 Terraform 状态文件
- 启用团队协作
- **绝不要将状态文件提交到源代码控制系统**
- 这可防止冲突并保持基础设施状态的一致性

## 9. 文档与架构图

- **保持文档的及时更新**
- **在代码变更时**，更新 `README.md` 中的变量、输出或使用说明
- 考虑使用工具如 `terraform-docs` 实现自动化
- **每次重大更新后**，更新架构图以反映基础设施变更
- 完善的文档和架构图确保团队所有成员都能理解基础设施

## 10. 验证和测试变更

- **运行 `terraform validate`** 并审查 `terraform plan` 输出后再应用变更
- 早期发现错误或意外修改
- **考虑实施自动化检查**：
  - 持续集成流水线
  - 提交前钩子
  - 强制执行格式化、代码检查和基础验证