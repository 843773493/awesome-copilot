

---
description: '遵循官方推荐编写 Dart 和 Flutter 代码的指南。'
applyTo: '**/*.dart'
---

# Dart 和 Flutter

Dart 和 Flutter 团队推荐的最佳实践。这些指导方针来源于 [Effective Dart](https://dart.dev/effective-dart) 和 [架构建议](https://docs.flutter.dev/app-architecture/recommendations)。

## 有效的 Dart

多年来，我们编写了大量的 Dart 代码，并学到了哪些做法有效，哪些做法不佳。我们与您分享这些经验，以便您也能编写出一致、健壮、高效的代码。主要有两个总体主题：

1. **保持一致性**。在格式、大小写、参数等事项上，关于哪种方式更好的争论是主观的且无法解决的。我们所知道的是，保持一致性是客观上有益的。

    如果两段代码看起来不同，那是因为它们在某些有意义的方面确实不同。当某段代码突出显示并引起您的注意时，它应该有合理的理由。

2. **简洁明了**。Dart 被设计为易于理解，因此继承了 C、Java、JavaScript 等语言的许多语句和表达式。但我们创建 Dart 是因为这些语言还有很大的改进空间。我们添加了许多功能，如字符串插值和初始化形式参数，以帮助您更简单地表达意图。

    如果有多种方式可以表达同一内容，您通常应选择最简洁的一种。这并不意味着您应该通过代码高尔夫（code golf）将整个程序压缩到一行。目标是写出*经济高效*的代码，而不是*密集*的代码。

### 主题

我们将指导方针分成几个独立的主题，以便于理解：

* **样式** – 这部分定义了代码布局和组织的规则，或至少是 `dart format` 无法处理的部分。样式主题还指定了标识符的格式：`camelCase`、`using_underscores` 等。

* **文档** – 这部分告诉您有关注释内容的所有信息。包括文档注释和普通的代码注释。

* **使用** – 这部分教您如何充分利用语言特性来实现行为。如果它出现在语句或表达式中，这里会涵盖。

* **设计** – 这是最宽泛的主题，但也是最柔和的。它涵盖了我们在设计一致、可用的库 API 时学到的经验。如果它出现在类型签名或声明中，这里会详细说明。

### 如何阅读这些主题

每个主题被分成几个部分。每个部分包含一系列指导方针。每条指导方针以以下词语之一开头：

* **应** – 指导方针描述了始终应遵循的做法。几乎不会有任何合理理由违反它们。

* **不要** – 指导方针是相反的：几乎从不建议的做法。希望我们不像其他语言那样有这么多这类指导方针，因为我们历史包袱较少。

* **优先** – 指导方针是您*应该*遵循的做法。然而，可能存在某些情况下选择其他方式更合理。只要您了解忽略该指导方针的全部后果即可。

* **避免** – 这是“优先”的对立面：您不应该做但偶尔有合理理由去做的事情。

* **考虑** – 指导方针是您可能或可能不想遵循的做法，这取决于具体情况、先例和您的个人偏好。

一些指导方针描述了**例外**，即规则不适用的情况。当列出例外时，它们可能并不全面——您仍可能需要在其他情况下自行判断。

这听起来像是如果您没有正确系鞋带，警察就会破门而入。事情并不那么糟糕。这里的大多数指导方针都是常识，我们都是理性的人。目标始终是写出*易于阅读、维护*的代码。

### 规则

#### 样式

##### 标识符

* **应**使用 `UpperCamelCase` 命名类型。
* **应**使用 `UpperCamelCase` 命名扩展。
* **应**使用 `lowercase_with_underscores` 命名包、目录和源文件。
* **应**使用 `lowercase_with_underscores` 命名导入前缀。
* **应**使用 `lowerCamelCase` 命名其他标识符。
* **优先**使用 `lowerCamelCase` 命名常量。
* **应**将长度超过两个字母的首字母缩写词和缩略词像单词一样大写。
* **优先**使用通配符处理未使用的回调参数。
* **不要**在非私有标识符前使用下划线。
* **不要**使用前缀字母。
* **不要**显式命名库。

##### 排序

* **应**将 `dart:` 导入放在其他导入之前。
* **应**将 `package:` 导入放在相对导入之前。
* **应**在所有导入之后，将导出单独列出。
* **应**按字母顺序排序各个部分。

##### 格式化

* **应**使用 `dart format` 格式化您的代码。
* **考虑**修改代码以使其更符合格式化工具的喜好。
* **优先**使用 80 个字符或更少的行。
* **应**在所有流程控制语句中使用大括号。

#### 文档

##### 注释

* **应**将注释格式化为句子。
* **不要**使用块注释进行文档说明。

##### 文档注释

* **应**使用 `///` 文档注释来说明成员和类型。
* **优先**为公共 API 编写文档注释。
* **考虑**为库级或类型级编写文档注释。
* **考虑**为私有 API 编写文档注释。
* **应**以单句摘要开头文档注释。
* **应**将文档注释中的第一句话单独成段。
* **避免**与上下文重复。
* **优先**如果函数或方法的主要目的是副作用，使用第三人称动词开头。
* **优先**如果变量或属性的主目的是返回值，使用名词短语开头。
* **优先**对于布尔变量或属性，使用 "Whether" 后接名词或动名词短语开头。
* **优先**如果返回值是主要目的，使用名词短语或非命令式动词短语。
* **不要**同时为属性的 getter 和 setter 编写文档。
* **优先**以名词短语开头库或类型注释。
* **考虑**在文档注释中包含代码示例。
* **应**在文档注释中使用方括号引用作用域内的标识符。
* **应**使用散文解释参数、返回值和异常。
* **应**在元数据注解之前放置文档注释。

##### Markdown

* **避免**过度使用 Markdown。
* **避免**使用 HTML 进行格式化。
* **优先**使用反引号围栏来表示代码块。

##### 写作

* **优先**简洁性。
* **避免**使用缩写和首字母缩写词，除非它们明显。
* **优先**使用 "this" 而不是 "the" 来指代成员的实例。

#### 使用

##### 库

* **应**在 `part of` 指令中使用字符串。
* **不要**导入其他包的 `src` 目录中的库。
* **不要**允许导入路径进入或离开 `lib`。
* **优先**使用相对导入路径。

##### 空值

* **不要**显式初始化变量为 `null`。
* **不要**使用显式的默认值 `null`。
* **不要**在等值操作中使用 `true` 或 `false`。
* **避免**在需要检查是否已初始化时使用 `late` 变量。
* **考虑**使用类型提升或空值检查模式来使用可空类型。

##### 字符串

* **应**使用相邻字符串来连接字符串字面量。
* **优先**使用插值来组合字符串和值。
* **避免**在不需要时使用花括号进行插值。

##### 集合

* **应**尽可能使用集合字面量。
* **不要**使用 `.length` 来判断集合是否为空。
* **避免**使用 `Iterable.forEach()` 与函数字面量。
* **不要**使用 `List.from()`，除非您打算更改结果的类型。
* **应**使用 `whereType()` 按类型过滤集合。
* **不要**在附近操作可用时使用 `cast()`。
* **避免**使用 `cast()`。

##### 函数

* **应**使用函数声明将函数绑定到名称。
* **不要**在 tear-off 可行时创建 lambda 表达式。

##### 变量

* **应**对局部变量的 `var` 和 `final` 保持一致规则。
* **避免**存储可以计算的内容。

##### 成员

* **不要**在不需要时对字段包裹 getter 和 setter。
* **优先**使用 `final` 字段来创建只读属性。
* **考虑**使用 `=>` 表示简单成员。
* **不要**使用 `this.` 除非是为了重定向到命名构造函数或避免遮蔽。
* **应**在可能的情况下在声明时初始化字段。

##### 构造函数

* **应**在可能的情况下使用初始化形式参数。
* **不要**在构造函数初始化列表可用时使用 `late`。
* **应**使用 `;` 而不是 `{}` 表示空构造函数体。
* **不要**使用 `new`。
* **不要**冗余使用 `const`。

##### 错误处理

* **避免**没有 `on` 子句的 catch 块。
* **不要**在没有 `on` 子句的 catch 块中丢弃错误。
* **应**仅在程序错误时抛出实现 `Error` 的对象。
* **不要**显式捕获 `Error` 或其类型。
* **应**使用 `rethrow` 重新抛出已捕获的异常。

##### 异步操作

* **优先**使用 async/await 而不是原始的 futures。
* **不要**在没有实际效果时使用 `async`。
* **考虑**使用高阶方法转换流。
* **避免**直接使用 Completer。
* **应**在区分 `Future<T>` 时测试 `FutureOr<T>` 的类型参数。
* **避免**使用 `FutureOr<T>` 作为返回类型。

#### 设计

##### 名称

* **应**保持术语的一致性。
* **避免**使用缩写。
* **优先**将最具描述性的名词放在最后。
* **考虑**使代码读起来像句子。
* **优先**使用名词短语表示非布尔属性或变量。
* **优先**使用非命令式动词短语表示布尔属性或变量。
* **考虑**在命名布尔参数时省略动词。
* **优先**使用“正向”名称表示布尔属性或变量。
* **优先**使用命令式动词短语表示主要目的是副作用的函数或方法。
* **优先**使用名词短语或非命令式动词短语表示主要目的是返回值的函数或方法。
* **考虑**在需要突出函数执行的工作时使用命令式动词短语。
* **避免**以 `get` 开头的方法名。
* **优先**如果方法复制对象状态到新对象，则命名为 `to...()`。
* **优先**如果方法返回原始对象的不同表示形式，则命名为 `as...()`。
* **避免**在函数或方法名中描述参数。
* **应**遵循现有的命名约定来命名类型参数。

##### 库

* **优先**使声明私有化。
* **考虑**在同一个库中声明多个类。

##### 类和混入

* **避免**在简单函数可行时定义单成员抽象类。
* **避免**定义仅包含静态成员的类。
* **避免**扩展不打算被子类化的类。
* **应**使用类修饰符来控制类是否可扩展。
* **避免**实现不打算作为接口的类。
* **应**使用类修饰符来控制类是否可作为接口。
* **优先**定义纯 `mixin` 或纯 `class` 而不是 `mixin class`。

##### 构造函数

* **考虑**如果类支持，使构造函数为 `const`。

##### 成员

* **优先**使字段和顶层变量为 `final`。
* **应**使用 getter 来封装概念上访问属性的操作。
* **应**使用 setter 来封装概念上修改属性的操作。
* **不要**在没有对应 getter 的情况下定义 setter。
* **避免**使用运行时类型测试来模拟重载。
* **避免**在公共 `late final` 字段中没有初始化器。
* **避免**返回可空的 `Future`、`Stream` 和集合类型。
* **避免**从方法中返回 `this` 仅仅是为了启用流畅接口。

##### 类型

* **应**为没有初始化器的变量添加类型注解。
* **应**为类型不明显的字段和顶层变量添加类型注解。
* **不要**冗余地为已初始化的局部变量添加类型注解。
* **应**在函数声明中注解返回类型。
* **应**在函数声明中注解参数类型。
* **不要**在函数表达式中注解推断的参数类型。
* **不要**为初始化形式参数添加类型注解。
* **应**在泛型调用未被推断时编写类型参数。
* **不要**在泛型调用被推断时编写类型参数。
* **避免**编写不完整的泛型类型。
* **应**使用 `dynamic` 而不是让推断失败。
* **优先**在函数类型注解中使用签名。
* **不要**为 setter 指定返回类型。
* **不要**使用旧版 typedef 语法。
* **优先**使用内联函数类型而非 typedef。
* **优先**使用函数类型语法表示参数。
* **避免**使用 `dynamic`，除非您想禁用静态检查。
* **应**将 `Future<void>` 作为不返回值的异步成员的返回类型。
* **避免**使用 `FutureOr<T>` 作为返回类型。

##### 参数

* **避免**使用位置布尔参数。
* **避免**在用户可能省略前面参数时使用可选位置参数。
* **避免**使用接受特殊“无参数”值的强制参数。
* **应**使用包含起始和结束参数的范围。

##### 等值

* **应**在重写 `==` 时重写 `hashCode`。
* **应**使您的 `==` 操作符遵守等值的数学规则。
* **避免**为可变类定义自定义等值。
* **不要**使 `==` 的参数可为空。

---

## Flutter 架构建议

本页面提出了架构最佳实践，解释了它们的重要性，并说明我们是否建议您在 Flutter 应用中采用这些实践。您应将这些建议视为建议，而非不可动摇的规则，并应根据您应用的特定需求进行调整。

本页面上的最佳实践有优先级，反映了 Flutter 团队推荐的程度。

* **强烈推荐**：如果您开始构建新应用，您应该始终实施此建议。如果您正在重构现有应用，除非这样做会与您当前的方法根本冲突，否则应强烈考虑实施此实践。
* **推荐**：此实践通常会改进您的应用。
* **条件性**：此实践在某些情况下可以改进您的应用。

### 关心分离

您应该将应用分为 UI 层和数据层。在这些层内，您还应根据职责进一步分离逻辑到类中。

#### 使用明确定义的数据和 UI 层。
**强烈推荐**

关心分离是最重要的架构原则。数据层将应用数据暴露给应用的其余部分，并包含应用中的大部分业务逻辑。UI 层显示应用数据并监听用户的事件。UI 层包含独立的 UI 逻辑类和小部件类。

#### 在数据层中使用仓储模式。
**强烈推荐**

仓储模式是一种软件设计模式，它将数据访问逻辑与应用的其余部分隔离。它在应用的业务逻辑和底层数据存储机制（数据库、API、文件系统等）之间创建一个抽象层。实际上，这意味着创建仓储类和服务类。

#### 在 UI 层中使用 ViewModel 和 Views（MVVM）
**强烈推荐**

关心分离是最重要的架构原则。这种特定的分离使您的代码更少出错，因为小部件保持“傻瓜式”。

#### 使用 `ChangeNotifiers` 和 `Listenables` 来处理小部件更新。
**条件性**

> 处理状态管理有许多选项，最终决策取决于个人偏好。

`ChangeNotifier` API 是 Flutter SDK 的一部分，是让您的小部件观察 ViewModel 中变化的便捷方式。

#### 不要在小部件中放置逻辑。
**强烈推荐**

逻辑应封装在 ViewModel 的方法中。小部件中唯一应包含的逻辑是：
* 基于 ViewModel 中的标志或可空字段的简单 if 语句来显示和隐藏小部件
* 依赖小部件计算的动画逻辑
* 基于设备信息的布局逻辑，如屏幕尺寸或方向
* 简单的路由逻辑

#### 使用领域层。
**条件性**

> 用于具有复杂逻辑需求的应用。

如果您的应用具有超出 ViewModel 能处理的复杂逻辑，或者您发现自己在 ViewModel 中重复逻辑，那么就需要领域层。在非常大的应用中，使用案例是有用的，但在大多数应用中它们会增加不必要的开销。

### 处理数据

谨慎处理数据会使您的代码更容易理解，减少错误，并防止创建格式错误或意外的数据。

#### 使用单向数据流。
**强烈推荐**

数据更新应仅从数据层流向 UI 层。UI 层的交互应发送到数据层进行处理。

#### 使用 `Commands` 处理用户交互事件。
**推荐**

Commands 可防止您的应用出现渲染错误，并标准化 UI 层向数据层发送事件的方式。

#### 使用不可变数据模型。
**强烈推荐**

不可变数据对于确保任何必要的更改仅在适当的位置发生（通常是数据或领域层）至关重要。由于不可变对象在创建后不能被修改，您必须创建新实例来反映更改。此过程可防止 UI 层中的意外更新，并支持清晰的单向数据流。

#### 使用 freezed 或 built_value 生成不可变数据模型。
**推荐**

您可以使用 `freezed` 或 `built_value` 等包来帮助生成数据模型的常用功能。这些可以生成 JSON 序列化/反序列化、深度等值检查和复制方法。这些代码生成包如果您的模型数量很多，可能会显著增加构建时间。

#### 创建独立的 API 模型和领域模型。
**条件性**

> 用于大型应用。

使用独立模型会增加冗余，但可以防止 ViewModel 和使用案例中的复杂性。

### 应用结构

良好组织的代码对应用本身和开发团队都有好处。

#### 使用依赖注入。
**强烈推荐**

依赖注入可防止您的应用中存在全局可访问的对象，从而使代码更少出错。我们建议您使用 `provider` 包来处理依赖注入。

#### 使用 `go_router` 进行导航。
**推荐**

`go_router` 是编写 90% Flutter 应用的首选方式。对于某些特定用例，`go_router` 无法解决，这时您可以直接使用 `Flutter 导航 API` 或尝试 `pub.dev` 上的其他包。

#### 使用标准化的类、文件和目录命名约定。
**推荐**

我们建议根据其代表的架构组件命名类。例如，您可能有以下类：

* HomeViewModel
* HomeScreen
* UserRepository
* ClientApiService

为了清晰，我们不建议使用可能与 Flutter SDK 中的对象混淆的名称。例如，您应该将共享的小部件放在名为 `ui/core/` 的目录中，而不是名为 `/widgets` 的目录。

#### 使用抽象仓储类。
**强烈推荐**

仓储类是应用中所有数据的来源，并促进与外部 API 的通信。创建抽象仓储类允许您为不同的应用环境（如“开发”和“测试”）创建不同的实现。