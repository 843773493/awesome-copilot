

---
description: '规范驱动工作流 v1 提供了一种结构化的方法来进行软件开发，确保需求明确定义，设计精心规划，实现过程充分记录和验证。'
applyTo: '**'
---
# 规范驱动工作流 v1

**规范驱动工作流：**  
弥合需求与实现之间的鸿沟。

**始终维护这些工件：**

- **`requirements.md`**：用户故事和验收标准的结构化 EARS 表示。
- **`design.md`**：技术架构、顺序图、实现注意事项。
- **`tasks.md`**：详细且可追踪的实现计划。

## 全面文档框架

**文档规则：**  
使用详细模板作为所有文档的**主要信息来源**。

**摘要格式：**  
仅用于生成简洁的工件，例如变更日志和拉取请求描述。

### 详细文档模板

#### 行动文档模板（所有步骤/执行/测试）

```bash
### [类型] - [行动] - [时间戳]
**目标**：[要完成的目标]
**上下文**：[当前状态、需求和对先前步骤的引用]
**决策**：[所选方法及理由，如适用可引用决策记录]
**执行**：[采取的步骤及使用的参数和命令。对于代码，包含文件路径。]
**输出**：[完整且无删减的结果、日志、命令输出和指标]
**验证**：[成功验证的方法和结果。若失败，包含补救计划。]
**下一步**：[自动延续到下一步特定行动的计划]
```

#### 决策记录模板（所有决策）

```bash
### 决策 - [时间戳]
**决策**：[所做决策]
**上下文**：[需要决策的情况及驱动决策的数据]
**选项**：[评估的替代方案及其简要优缺点]
**理由**：[为何所选选项更优，明确说明权衡]
**影响**：[对实现、可维护性和性能的预期后果]
**审查**：[重新评估此决策的条件或时间表]
```

### 摘要格式（用于报告）

#### 精简行动日志

用于生成简洁的变更日志。每个日志条目均源自完整的行动文档。

`[类型][时间戳] 目标: [X] → 行动: [Y] → 结果: [Z] → 下一步: [W]`

#### 压缩决策记录

用于拉取请求摘要或高层摘要。

`决策: [X] | 理由: [Y] | 影响: [Z] | 审查: [日期]`

## 执行工作流（6阶段循环）

**绝不跳过任何步骤。使用一致的术语。减少歧义。**

### **阶段1：分析**

**目标：**

- 理解问题。
- 分析现有系统。
- 生成清晰、可测试的需求集合。
- 考虑可能的解决方案及其影响。

**检查清单：**

- [ ] 阅读所有提供的代码、文档、测试和日志。
      - 记录文件清单、摘要和初始分析结果。
- [ ] 用 **EARS 表示法** 定义需求：
      - 将功能请求转换为结构化、可测试的需求。
      - 格式：`当 [条件或事件] 时，系统应 [预期行为]`
- [ ] 识别依赖项和约束条件。
      - 记录依赖关系图，包含风险和缓解策略。
- [ ] 映射数据流和交互。
      - 记录系统交互图和数据模型。
- [ ] 编目边缘情况和失败场景。
      - 记录全面的边缘情况矩阵和潜在失败点。
- [ ] 评估置信度。
      - 根据需求清晰度、复杂性和问题范围生成 **置信度评分（0-100%）**。
      - 记录评分及其理由。

**关键约束：**

- **在所有需求清晰且文档化之前，不得继续进行。**

### **阶段2：设计**

**目标：**

- 创建全面的技术设计和详细的实现计划。

**检查清单：**

- [ ] **根据置信度评分定义适应性执行策略：**
  - **高置信度（>85%）**
    - 草拟全面的、分步骤的实现计划。
    - 跳过概念验证步骤。
    - 采用完整的自动化实现。
    - 保持标准的全面文档。
  - **中置信度（66–85%）**
    - 优先考虑 **概念验证（PoC）** 或 **最小可行产品（MVP）**。
    - 定义 PoC/MVP 的明确成功标准。
    - 先构建并验证 PoC/MVP，再逐步扩展计划。
    - 记录 PoC/MVP 的目标、执行和验证结果。
  - **低置信度（<66%）**
    - 将第一阶段用于研究和知识构建。
    - 使用语义搜索并分析类似实现。
    - 将研究结果综合为研究文档。
    - 研究完成后重新运行分析阶段。
    - 若置信度仍低，需升级处理。

- [ ] **在 `design.md` 中记录技术设计：**
  - **架构**：组件和交互的高层概述。
  - **数据流**：图表和描述。
  - **接口**：API 协议、模式、公开函数签名。
  - **数据模型**：数据结构和数据库模式。

- [ ] **记录错误处理：**
  - 创建包含处理流程和预期响应的错误矩阵。

- [ ] **定义单元测试策略。**

- [ ] **在 `tasks.md` 中创建实现计划：**
  - 每个任务需包含描述、预期成果和依赖项。

**关键约束：**

- **在设计和计划完成并验证之前，不得进入实现阶段。**

### **阶段3：实现**

**目标：**

- 根据设计和计划编写生产质量代码。

**检查清单：**

- [ ] 以小块、可测试的方式编写代码。
      - 用代码变更、结果和测试链接记录每个增量。
- [ ] 从依赖项开始逐步实现。
      - 记录解决顺序、理由和验证过程。
- [ ] 遵循约定。
      - 记录遵循情况以及任何偏离的决策记录。
- [ ] 添加有意义的注释。
      - 聚焦意图（"为什么"），而非机械细节（"是什么"）。
- [ ] 创建计划中的文件。
      - 记录文件创建日志。
- [ ] 实时更新任务状态。

**关键约束：**

- **在所有实现步骤记录并测试完成之前，不得合并或部署代码。**

### **阶段4：验证**

**目标：**

- 验证实现是否满足所有需求和质量标准。

**检查清单：**

- [ ] 执行自动化测试。
      - 记录输出、日志和覆盖率报告。
      - 对于失败，记录根本原因分析和补救措施。
- [ ] 如有必要，执行手动验证。
      - 记录流程、检查清单和结果。
- [ ] 测试边缘情况和错误。
      - 记录结果和正确错误处理的证据。
- [ ] 验证性能。
      - 记录指标并分析关键部分。
- [ ] 记录执行追踪。
      - 记录路径分析和运行时行为。

**关键约束：**

- **在所有验证步骤完成且所有问题解决之前，不得继续进行。**

### **阶段5：反思**

**目标：**

- 改进代码库、更新文档并分析性能。

**检查清单：**

- [ ] 为可维护性进行重构。
      - 记录决策、前后对比和影响。
- [ ] 更新所有项目文档。
      - 确保所有 README、图表和注释均为最新。
- [ ] 识别潜在改进点。
      - 用优先级记录待办事项。
- [ ] 验证成功标准。
      - 记录最终验证矩阵。
- [ ] 进行元分析。
      - 反思效率、工具使用和协议遵循情况。
- [ ] 自动生成技术债务问题。
      - 记录库存和补救计划。

**关键约束：**

- **在所有文档和改进措施记录完毕之前，不得关闭该阶段。**

### **阶段6：交接**

**目标：**

- 将工作打包用于评审和部署，并过渡到下一步任务。

**检查清单：**

- [ ] 生成高层摘要。
      - 使用 **压缩决策记录** 格式。
- [ ] 准备拉取请求（如适用）：
    1. 高层摘要。
    2. 从 **精简行动日志** 中提取变更日志。
    3. 链接到验证工件和决策记录。
    4. 链接到最终的 `requirements.md`、`design.md` 和 `tasks.md`。
- [ ] 最终整理工作区。
      - 将中间文件、日志和临时工件归档到 `.agent_work/`。
- [ ] 过渡到下一步任务。
      - 记录过渡或完成情况。

**关键约束：**

- **在所有交接步骤完成并记录之前，不得认为任务完成。**

## 故障排查与重试协议

**如果遇到错误、歧义或阻塞问题：**

**检查清单：**

1. **重新分析**：
   - 重新审视分析阶段。
   - 确认所有需求和约束条件清晰且完整。
2. **重新设计**：
   - 重新审视设计阶段。
   - 如有需要，更新技术设计、计划或依赖项。
3. **重新规划**：
   - 调整 `tasks.md` 中的实现计划以应对新发现。
4. **重试执行**：
   - 用修正后的参数或逻辑重新执行失败步骤。
5. **升级处理**：
   - 若重试后问题仍未解决，遵循升级协议。

**关键约束：**

- **绝不继续处理未解决的错误或歧义。始终记录故障排查步骤和结果。**

## 技术债务管理（自动化）

### 识别与记录

- **代码质量**：在实现过程中持续评估代码质量，使用静态分析。
- **快捷方式**：在决策记录中明确记录所有以速度优先于质量的决定及其后果。
- **工作区**：监控组织偏差和命名不一致。
- **文档**：跟踪不完整、过时或缺失的文档。

### 自动创建问题模板

```text
**标题**：[技术债务] - [简要描述]
**优先级**：[基于业务影响和修复成本的高/中/低]
**位置**：[文件路径和行号]
**原因**：[为何产生债务，如有决策记录可链接]
**影响**：[当前和未来后果（例如：减缓开发、增加错误风险）]
**修复措施**：[具体的、可操作的解决步骤]
**工作量**：[修复估计（例如：T恤尺码：S、M、L）]
```

### 修复（自动优先级）

- 基于风险的优先级排序，结合依赖分析。
- 工作量估算以辅助未来规划。
- 提出大型重构工作的迁移策略。

## 质量保证（自动化）

### 持续监控

- **静态分析**：代码风格、质量、安全漏洞和架构规则的检查。
- **动态分析**：在预发布环境中监控运行时行为和性能。
- **文档**：自动检查文档的完整性和准确性（例如：链接、格式）。

### 质量指标（自动跟踪）

- 代码覆盖率百分比及差距分析。
- 每个函数/方法的环复杂度评分。
- 可维护性指数评估。
- 技术债务比率（例如：预估修复时间与开发时间的对比）。
- 文档覆盖率百分比（例如：带注释的公共方法）。

## EARS 表示法参考

**EARS（需求语法的简易方法）** - 需求的标准格式：

- **普遍性**：`系统应 [预期行为]`
- **事件驱动**：`当 [触发事件] 时，系统应 [预期行为]`
- **状态驱动**：`当 [处于特定状态] 时，系统应 [预期行为]`
- **不期望行为**：`如果 [不期望条件] 则系统应 [所需响应]`
- **可选**：`当 [功能被包含] 时，系统应 [预期行为]`
- **复杂**：通过上述模式的组合表示复杂需求。

每个需求必须满足以下条件：

- **可测试性**：可通过自动化或手动测试验证
- **无歧义性**：仅有一种可能的解释
- **必要性**：有助于系统目的
- **可行性**：可在约束条件下实现
- **可追溯性**：链接到用户需求和设计元素