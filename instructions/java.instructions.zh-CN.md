

---
description: '构建 Java 基础应用程序的指南'
applyTo: '**/*.java'
---

# Java 开发

## 通用指南

- 首先，询问用户是否希望将静态分析工具（SonarQube、PMD、Checkstyle）集成到项目设置中。
  - 如果用户同意，需记录推荐的静态分析配置。
    - 优先使用 SonarQube/SonarCloud（IDE 中的 SonarLint + CI 中的 `sonar-scanner`）。
    - 创建 Sonar 项目密钥。
    - 将扫描器令牌存储在 CI 密钥中。
    - 提供一个运行扫描器的示例 CI 任务。
    - 如果团队拒绝使用 Sonar，需在项目 README 中注明此情况并继续。
  - 如果 Sonar 已绑定到项目：
    - 以 Sonar 作为可操作问题的主要来源。
    - 在修复指南中引用 Sonar 规则密钥。
  - 如果 Sonar 不可用：
    - 进行最多 3 次故障排查：
      1. 验证项目绑定和令牌。
      2. 确保 SonarScanner 在 CI 中运行。
      3. 确认 SonarLint 已安装并配置。
    - 如果经过 3 次尝试后仍失败：
      - 启用 SpotBugs、PMD 或 Checkstyle 作为 CI 的备用方案。
      - 打开一个简短的跟踪问题，记录阻塞项和下一步计划。
- 如果用户拒绝使用静态分析工具或希望直接跳过这些工具，继续实施以下列出的最佳实践、常见错误模式和代码异味预防指南。
- 在开发过程中主动处理代码异味，而不是积累技术债务。
- 在重构已识别的问题时，专注于可读性、可维护性和性能。
- 利用 IDE / 代码编辑器报告的警告和建议，在开发早期捕获常见模式。

## 最佳实践

- **记录（Records）**：对于主要用于存储数据的类（例如 DTO、不可变数据结构），**应使用 Java 记录（Records）而非传统类**。
- **模式匹配**：使用模式匹配简化 `instanceof` 和 `switch` 表达式的条件逻辑和类型转换。
- **类型推断**：使用 `var` 声明局部变量以提高可读性，但仅当表达式右侧的类型明确时才使用。
- **不可变性**：优先使用不可变对象。尽可能将类和字段设为 `final`。使用 `List.of()`/`Map.of()` 创建固定数据的集合。使用 `Stream.toList()` 创建不可变列表。
- **流和 Lambda 表达式**：使用 Streams API 和 Lambda 表达式处理集合。使用方法引用（例如 `stream.map(Foo::toBar)`）。
- **空值处理**：避免返回或接受 `null`。对于可能缺失的值，使用 `Optional<T>`，并使用 `Objects` 工具类的方法（如 `equals()` 和 `requireNonNull()`）。

### 命名规范

- 遵循 Google 的 Java 风格指南：
  - 类和接口名称使用 `UpperCamelCase`。
  - 方法和变量名称使用 `lowerCamelCase`。
  - 常量使用 `UPPER_SNAKE_CASE`。
  - 包名称使用 `lowercase`。
- 使用名词作为类名（如 `UserService`），使用动词作为方法名（如 `getUserById`）。
- 避免使用缩写和匈牙利命名法。

### 常见错误模式

以下是无论使用哪种静态分析工具均可应用的简洁、可读性强的规则。如果运行 Sonar/SonarLint，IDE 将显示匹配的规则密钥（例如，资源泄漏的 S2095）和受影响的文件/行号。建议优先使用直接的 Sonar 连接，并覆盖此规则集。

- 资源管理 — 始终关闭资源（如文件、套接字、流）。尽可能使用 try-with-resources，以便自动关闭资源。
- 对象相等性检查 — 对于非基本类型，使用 `.equals()` 或 `Objects.equals(...)` 进行对象相等性比较，而不是 `==`，以避免引用相等性错误。
- 冗余类型转换 — 移除不必要的类型转换；优先使用正确的泛型类型，让编译器尽可能推断类型。
- 永远为真的条件表达式 — 避免条件表达式始终为 true 或 false；这表明存在错误或死代码，应进行修正。

对于确实使用 Sonar 或 SonarLint 的贡献者：IDE/扫描将显示具体的规则密钥（例如，资源泄漏的 S2095）和受影响的文件/行号。使用这些信息导航到确切位置，然后应用推荐的修复方案。

### 常见代码异味

这些模式以人类可读的方式表述，它们可以很好地映射到 Sonar、SpotBugs、PMD 或 Checkstyle 的检查，但并不需要这些工具才能实用。

- 参数数量 — 保持方法参数列表简短。如果方法需要多个参数，考虑将其封装为值对象或使用构建器模式。
- 方法大小 — 保持方法专注且简短。提取辅助方法以提高可读性和可测试性。
- 认知复杂度 — 通过提取方法、使用多态性或应用策略模式来减少嵌套条件和复杂分支。
- 重复字面量 — 将重复的字符串和数字提取为命名常量或枚举，以减少错误并简化更改。
- 死代码 — 删除未使用的变量和赋值。它们会混淆读者并可能隐藏错误。
- 魔法数字 — 用具有解释意图的命名常量替换数字字面量（例如，MAX_RETRIES）。

如果运行 Sonar 或 SonarLint 等静态分析工具，建议优先使用直接的 Sonar 连接，并覆盖此规则集。Sonar 规则密钥对自动化和抑制很有用，但它们在日常开发指导中并非必需。

## 构建与验证

- 在添加或修改代码后，验证项目是否仍能成功构建。
- 如果项目使用 Maven，运行 `mvn clean install`。
- 如果项目使用 Gradle，运行 `./gradlew build`（或在 Windows 上运行 `gradlew.bat build`）。
- 确保构建过程中所有测试都能通过。