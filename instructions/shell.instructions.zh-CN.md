

---
description: 'bash、sh、zsh及其他shell的Shell脚本最佳实践和约定'
applyTo: '**/*.sh'
---

# Shell脚本编写指南

编写干净、安全且易于维护的bash、sh、zsh及其他shell脚本的指导原则。

## 通用原则

- 生成整洁、简洁、清晰的代码
- 确保脚本易于阅读和理解
- 在有助于理解脚本运行原理的地方添加注释
- 生成简洁且简单的echo输出以提供执行状态
- 避免不必要的echo输出和过度日志记录
- 在可用时使用shellcheck进行静态分析
- 假设脚本用于自动化和测试而非生产系统，除非另有说明
- 优先使用安全的变量展开：双引号引用变量（`"$var"`），使用`${var}`以提高可读性，避免使用`eval`
- 在可接受的情况下使用现代Bash特性（`[[ ]]`、`local`、数组），仅在需要时回退到POSIX构造
- 选择可靠的解析器处理结构化数据，而非临时文本处理

## 错误处理与安全性

- 始终启用`set -euo pipefail`以实现快速失败，捕获未设置的变量，并暴露管道失败
- 在执行前验证所有必需参数
- 提供包含上下文的清晰错误信息
- 使用`trap`清理临时资源或处理脚本终止时的意外退出
- 使用`readonly`（或`declare -r`）声明不可变值以防止意外重新赋值
- 使用`mktemp`安全地创建临时文件或目录，并确保在清理处理程序中移除它们

## 脚本结构

- 以清晰的shebang开头：`#!/bin/bash`，除非另有指定
- 包含解释脚本用途的头部注释
- 在顶部定义所有变量的默认值
- 使用函数封装可重用的代码块
- 创建可重用的函数，而非重复相似的代码块
- 保持主执行流程的整洁和可读性

## 处理JSON和YAML

- 优先使用专用解析器（JSON使用`jq`，YAML使用`yq`——或使用`yq`转换后的`jq`）而非`grep`、`awk`或shell字符串分割进行临时文本处理
- 当`jq`/`yq`不可用或不适用时，选择环境中最可靠的替代解析器，并明确说明如何安全使用
- 验证必需字段是否存在，并显式处理缺失/无效的数据路径（例如，通过检查`jq`的退出状态或使用`// empty`）
- 引用`jq`/`yq`过滤器以防止shell展开，并在需要纯字符串时优先使用`--raw-output`
- 将解析器错误视为致命错误：结合`set -euo pipefail`或在使用结果前测试命令成功状态
- 在脚本顶部记录解析器依赖项，若`jq`/`yq`（或替代工具）必需但未安装，则快速失败并显示有帮助的提示信息

```bash
#!/bin/bash

# ============================================================================
# 脚本描述在此处
# ============================================================================

set -euo pipefail

cleanup() {
    # 根据需要移除临时资源或执行其他清理步骤
    if [[ -n "${TEMP_DIR:-}" && -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
}

trap cleanup EXIT

# 默认值
RESOURCE_GROUP=""
REQUIRED_PARAM=""
OPTIONAL_PARAM="default-value"
readonly SCRIPT_NAME="$(basename "$0")"

TEMP_DIR=""

# 函数
usage() {
    echo "用法: $SCRIPT_NAME [选项]"
    echo "选项:"
    echo "  -g, --resource-group   资源组（必需）"
    echo "  -h, --help            显示此帮助"
    exit 0
}

validate_requirements() {
    if [[ -z "$RESOURCE_GROUP" ]]; then
        echo "错误: 资源组是必需的"
        exit 1
    fi
}

main() {
    validate_requirements

    TEMP_DIR="$(mktemp -d)"
    if [[ ! -d "$TEMP_DIR" ]]; then
        echo "错误: 无法创建临时目录" >&2
        exit 1
    fi
    
    echo "============================================================================"
    echo "脚本执行开始"
    echo "============================================================================"
    
    # 主逻辑在此处
    
    echo "============================================================================"
    echo "脚本执行完成"
    echo "============================================================================"
}

# 解析参数
while [[ $# -gt 0 ]]; do
    case $1 in
        -g|--resource-group)
            RESOURCE_GROUP="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "未知选项: $1"
            exit 1
            ;;
    esac
done

# 执行主函数
main "$@"

```