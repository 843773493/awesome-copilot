

---
description: '遵循Go习惯用法和社区标准编写Go代码的指南'
applyTo: '**/*.go,**/go.mod,**/go.sum'
---

# Go开发指南

在编写Go代码时，请遵循Go习惯用法和社区标准。这些指南基于 [Effective Go](https://go.dev/doc/effective_go)、[Go代码审查注释](https://go.dev/wiki/CodeReviewComments) 以及 [Google的Go风格指南](https://google.github.io/styleguide/go/)。

## 通用指南

- 编写简单、清晰且符合Go习惯的Go代码
- 优先选择清晰和简洁而非巧妙
- 遵循最小惊讶原则
- 保持“正常流程”左对齐（最小化缩进）
- 提前返回以减少嵌套
- 优先使用早期返回而非if-else链；使用 `if condition { return }` 模式以避免else块
- 使零值具有实用性
- 使用清晰、描述性的名称编写自文档化的代码
- 文档化导出的类型、函数、方法和包
- 使用Go模块进行依赖管理
- 优先使用Go标准库而非重复造轮子（例如，使用 `strings.Builder` 进行字符串拼接，使用 `filepath.Join` 进行路径构建）
- 在功能已存在时，优先使用标准库解决方案而非自定义实现
- 默认使用英文编写注释；仅在用户明确要求时进行翻译
- 避免在代码和注释中使用表情符号

## 命名规范

### 包

- 使用小写、单单词的包名
- 避免使用下划线、连字符或混合大小写
- 选择描述包提供功能的名称，而非其包含的内容
- 避免使用通用名称如 `util`、`common` 或 `base`
- 包名应为单数形式，而非复数

#### 包声明规则（关键）：
- **绝对不要重复 `package` 声明** - 每个Go文件必须有且仅有一个 `package` 行
- 在编辑现有 `.go` 文件时：
  - **保留现有的 `package` 声明** - 不要添加另一个
  - 如果需要替换整个文件内容，请以现有的包名开头
- 在创建新 `.go` 文件时：
  - **在编写任何代码之前**，检查同一目录中其他 `.go` 文件使用的包名
  - 使用该目录中现有文件的相同包名
  - 如果是新目录，请使用目录名作为包名
  - 在文件顶部**精确地写入**一个 `package <name>` 行
- 在使用文件创建或替换工具时：
  - **始终验证**目标文件是否已有 `package` 声明，再添加一个
  - 如果替换文件内容，新内容中仅包含一个 `package` 声明
  - **绝不**创建包含多个 `package` 行或重复声明的文件

### 变量和函数

- 使用混合大小写（MixedCaps）或驼峰命名法（camelCase）而非下划线
- 保持名称简短但具有描述性
- 仅在极短的作用域（如循环索引）中使用单字母变量
- 导出的名称以大写字母开头
- 未导出的名称以小写字母开头
- 避免重复命名（例如，避免 `http.HTTPServer`，优先使用 `http.Server`）

### 接口

- 在可能的情况下，使用 -er 后缀命名接口（例如：`Reader`、`Writer`、`Formatter`）
- 单方法接口应以方法名命名（例如：`Read` → `Reader`）
- 保持接口小巧且专注

### 常量

- 导出的常量使用 MixedCaps
- 未导出的常量使用 mixedCaps
- 使用 `const` 块分组相关常量
- 考虑使用类型化常量以提高类型安全性

## 代码风格和格式化

### 格式化

- 始终使用 `gofmt` 格式化代码
- 使用 `goimports` 自动管理导入
- 保持行长度合理（没有硬性限制，但需考虑可读性）
- 使用空行分隔逻辑代码组

### 注释

- 力求自文档化的代码；优先使用清晰的变量名、函数名和代码结构，而非注释
- 仅在必要时编写注释以解释复杂逻辑、业务规则或非显而易见的行为
- 默认使用完整的英文句子编写注释
- 仅在特定用户请求时翻译注释到其他语言
- 注释句子以被描述的事物名称开头
- 包注释应以 "Package [name]" 开头
- 使用行注释（`//`）处理大多数注释
- 稀疏使用块注释（`/* */`），主要用于包文档
- 除非逻辑复杂，否则注释应说明“为什么”而非“是什么”
- 避免在注释和代码中使用表情符号

## 错误处理模式

### 创建错误

- 使用 `errors.New` 用于简单的静态错误
- 使用 `fmt.Errorf` 用于动态错误
- 为领域特定错误创建自定义错误类型
- 导出错误变量用于哨兵错误
- 使用 `errors.Is` 和 `errors.As` 进行错误检查

### 错误传播

- 在传播错误时添加上下文
- 不要同时记录和返回错误（选择其一）
- 在适当层级处理错误
- 考虑使用结构化错误以提高调试能力

## API设计

### HTTP处理程序

- 使用 `http.HandlerFunc` 用于简单的处理程序
- 实现 `http.Handler` 用于需要状态的处理程序
- 使用中间件处理横切关注点
- 设置适当的HTTP状态码和头信息
- 优雅处理错误并返回适当的错误响应
- 根据Go版本选择路由器：
  - 如果 `go >= 1.22`，优先使用增强的 `net/http` `ServeMux`，基于模式的路由和方法匹配
  - 如果 `go < 1.22`，使用经典 `ServeMux` 并手动处理方法和路径（或在合理情况下使用第三方路由器）

### JSON API

- 使用结构标签控制JSON编组
- 验证输入数据
- 使用指针表示可选字段
- 考虑使用 `json.RawMessage` 进行延迟解析
- 适当处理JSON错误

### HTTP客户端

- 保持客户端结构专注于配置和依赖项（例如：基础URL、`*http.Client`、认证、默认头信息）。它不得存储每请求状态
- 不要在客户端结构中存储或缓存 `*http.Request`，也不得在调用之间保留请求特定状态；相反，每次方法调用时构建一个新的请求
- 方法应接受 `context.Context` 和输入参数，本地（或通过每次调用创建的短生命周期构建器/辅助函数）组装 `*http.Request`，然后调用 `c.httpClient.Do(req)`
- 如果请求构建逻辑被重复使用，请将其封装到未导出的辅助函数或每次调用的构建器类型中；绝不将 `http.Request`（URL参数、正文、头信息）作为长生命周期客户端的字段
- 确保底层 `*http.Client` 配置（超时、传输）并适用于并发使用；避免在首次使用后修改 `Transport`
- 始终在发送请求的实例上设置头信息，并关闭响应正文（`defer resp.Body.Close()`），适当处理错误

## 性能优化

### 内存管理

- 在热点路径中尽量减少分配
- 在可能时重用对象（考虑 `sync.Pool`）
- 对于小结构体使用值接收者
- 在已知大小时预分配切片
- 避免不必要的字符串转换

### I/O：读取器和缓冲区

- 大多数 `io.Reader` 流仅可一次性读取；读取会推进状态。不要假设读取器可以在特殊处理之外被重新读取
- 如果必须多次读取数据，请先缓冲一次，并在每次重用时创建新的读取器：
  - 使用 `io.ReadAll`（或有限读取）获取 `[]byte`，然后通过 `bytes.NewReader(buf)` 或 `bytes.NewBuffer(buf)` 为每次重用创建新的读取器
  - 对于字符串，使用 `strings.NewReader(s)`；可以在 `*bytes.Reader` 上使用 `Seek(0, io.SeekStart)` 来回退
- 对于HTTP请求，不要重用已消费的 `req.Body`。相反：
  - 将原始负载保存为 `[]byte`，并在每次发送前设置 `req.Body = io.NopCloser(bytes.NewReader(buf))`
  - 优先配置 `req.GetBody`，以便传输层可以为重定向或重试重新创建正文：`req.GetBody = func() (io.ReadCloser, error) { return io.NopCloser(bytes.NewReader(buf)), nil }`
- 用于流式传输的 `io.Pipe`：
  - 在单独的goroutine中向 `*io.PipeWriter` 写入，同时读取器消费
  - 始终关闭写入器；在失败时使用 `CloseWithError(err)`
  - `io.Pipe` 用于流式传输，而非回退或使读取器可重用

- **警告**：在使用 `io.Pipe`（尤其是与multipart写入器一起使用时），所有写入必须严格按顺序进行。不要并发写入或按顺序写入—multipart边界和分块顺序必须保持。无序或并行写入可能导致流损坏并引发错误。

- 使用 `io.Pipe` 流式传输multipart/form-data：
  - `pr, pw := io.Pipe()`；`mw := multipart.NewWriter(pw)`；使用 `pr` 作为HTTP请求正文
  - 设置 `Content-Type` 为 `mw.FormDataContentType()`
  - 在goroutine中：按正确顺序向 `mw` 写入所有部分；在错误时 `pw.CloseWithError(err)`；在成功时 `mw.Close()` 然后 `pw.Close()`
  - 不要在长生命周期的客户端中存储请求/正在进行的表单状态；每次调用时构建
  - 流式正文不可回退；对于重试/重定向，缓冲小负载或提供 `GetBody`

### 分析

- 使用内置分析工具（`pprof`）
- 对关键代码路径进行基准测试
- 在优化前进行分析
- 首先关注算法改进
- 考虑使用 `testing.B` 进行基准测试

## 测试

### 测试组织

- 保持测试在同一个包中（白盒测试）
- 使用 `_test` 包后缀进行黑盒测试
- 以 `_test.go` 为后缀命名测试文件
- 将测试文件与被测试代码放在一起

### 编写测试

- 使用表格驱动测试处理多个测试用例
- 使用 `Test_functionName_scenario` 这样的格式命名测试
- 使用 `t.Run` 子测试提高组织性
- 测试成功和错误情况
- 在测试和基准测试中使用 `testify` 或类似库时，仅在它们能提供价值时使用，不要过度复杂化简单测试

### 测试辅助函数

- 用 `t.Helper()` 标记辅助函数
- 为复杂设置创建测试fixture
- 使用 `testing.TB` 接口编写用于测试和基准测试的函数
- 使用 `t.Cleanup()` 清理资源

## 安全最佳实践

### 输入验证

- 验证所有外部输入
- 使用强类型防止无效状态
- 在使用SQL查询前对数据进行清理
- 注意用户输入的文件路径
- 针对不同上下文（HTML、SQL、shell）验证和转义数据

### 加密

- 使用标准库中的加密包
- 不要自行实现加密
- 使用 `crypto/rand` 进行随机数生成
- 使用 bcrypt、scrypt 或 argon2 存储密码（考虑 golang.org/x/crypto 提供的额外选项）
- 使用 TLS 进行网络通信

## 文档

### 代码文档

- 通过清晰的命名和结构优先实现自文档化的代码
- 为所有导出符号提供清晰、简洁的解释
- 文档以符号名称开头
- 默认使用英文编写文档
- 在需要时在文档中使用示例
- 将文档与代码保持接近
- 在代码更改时更新文档
- 避免在文档和注释中使用表情符号

### README和文档文件

- 包含清晰的设置说明
- 文档化依赖项和需求
- 提供使用示例
- 文档化配置选项
- 包含故障排除部分

## 工具和开发流程

### 必备工具

- `go fmt`：格式化代码
- `go vet`：查找可疑构造
- `golangci-lint`：额外的检查（golint已弃用）
- `go test`：运行测试
- `go mod`：管理依赖项
- `go generate`：代码生成

### 开发实践

- 提交前运行测试
- 使用预提交钩子进行格式化和检查
- 保持提交内容聚焦且原子
- 编写有意义的提交信息
- 提交前审查差异

## 常见陷阱避免

- 忽略错误检查
- 忽视竞态条件
- 创建goroutine泄漏
- 忘记使用 `defer` 进行清理
- 并发修改映射
- 不理解 nil 接口与 nil 指针的区别
- 忘记关闭资源（文件、连接）
- 不必要地使用全局变量
- 过度使用无约束类型（例如：`any`）；优先使用特定类型或带有约束的泛型类型参数。如果必须使用无约束类型，请使用 `any` 而非 `interface{}` 
- 忽视类型零值
- **创建重复的 `package` 声明** - 这是编译错误；在添加包声明前，始终检查现有文件