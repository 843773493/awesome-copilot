

---
description: 'Rust编程语言的编码规范和最佳实践'
applyTo: '**/*.rs'
---

# Rust编码规范和最佳实践

在编写Rust代码时，请遵循Rust惯用法和社区标准。

这些指导方针基于 [The Rust Book](https://doc.rust-lang.org/book/)、[Rust API指南](https://rust-lang.github.io/api-guidelines/)、[RFC 430命名规范](https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md) 以及更广泛的Rust社区 [users.rust-lang.org](https://users.rust-lang.org)。

## 通用指导方针

- 始终优先考虑可读性、安全性和可维护性。
- 使用强类型并利用Rust的所有权系统来确保内存安全。
- 将复杂的函数拆分为更小、更易管理的函数。
- 对于算法相关代码，包含所采用方法的解释。
- 编写具有良好可维护性实践的代码，包括对某些设计决策的注释。
- 使用 `Result<T, E>` 优雅处理错误，并提供有意义的错误信息。
- 对于外部依赖项，在文档中说明其用途和使用方式。
- 使用符合 [RFC 430](https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md) 的一致命名规范。
- 编写符合借用检查器规则的惯用、安全且高效的Rust代码。
- 确保代码在无警告的情况下编译通过。

## 应遵循的模式

- 使用模块 (`mod`) 和公共接口 (`pub`) 封装逻辑。
- 使用 `?`、`match` 或 `if let` 正确处理错误。
- 使用 `serde` 进行序列化，使用 `thiserror` 或 `anyhow` 实现自定义错误。
- 通过实现特质来抽象服务或外部依赖项。
- 使用 `async/await` 和 `tokio` 或 `async-std` 结构异步代码。
- 优先使用枚举而非标志和状态来实现类型安全。
- 对于复杂对象的创建，使用构建器（builders）。
- 将二进制和库代码（`main.rs` vs `lib.rs`）拆分以提高可测试性和可重用性。
- 使用 `rayon` 实现数据并行和CPU密集型任务。
- 使用迭代器而非基于索引的循环，因为它们通常更快且更安全。
- 在不需要所有权时，使用 `&str` 而非 `String` 作为函数参数。
- 优先使用借用和零拷贝操作以避免不必要的内存分配。

### 所有权、借用和生命周期

- 除非需要所有权转移，否则优先使用借用 (`&T`) 而非克隆。
- 需要修改借用数据时使用 `&mut T`。
- 当编译器无法推断时，显式标注生命周期。
- 在单线程环境中使用 `Rc<T>` 实现单引用计数，在多线程环境中使用 `Arc<T>` 实现线程安全的引用计数。
- 在单线程上下文中使用 `RefCell<T>` 实现内部可变性，在多线程上下文中使用 `Mutex<T>` 或 `RwLock<T>`。

## 应避免的模式

- 除非绝对必要，否则不要使用 `unwrap()` 或 `expect()`，优先使用正确的错误处理。
- 在库代码中避免引发恐慌，改为返回 `Result`。
- 不要依赖全局可变状态，使用依赖注入或线程安全容器。
- 避免深度嵌套的逻辑，通过函数或组合器进行重构。
- 不要忽略警告，在CI过程中将其视为错误。
- 除非必要且充分文档化，否则避免使用 `unsafe`。
- 不要过度使用 `clone()`，除非需要所有权转移，否则优先使用借用。
- 避免过早使用 `collect()`，保持迭代器的惰性直到真正需要集合。
- 避免不必要的内存分配，优先使用借用和零拷贝操作。

## 代码风格和格式

- 遵循Rust风格指南，并使用 `rustfmt` 进行自动格式化。
- 尽可能保持行宽在100个字符以内。
- 使用 `///` 在项目前直接为函数和结构体添加文档注释。
- 使用 `cargo clippy` 捕获常见错误并强制执行最佳实践。

## 错误处理

- 对于可恢复的错误使用 `Result<T, E>`，仅在不可恢复的错误时使用 `panic!`。
- 优先使用 `?` 运算符而非 `unwrap()` 或 `expect()` 进行错误传播。
- 使用 `thiserror` 创建自定义错误类型，或实现 `std::error::Error`。
- 对于可能不存在的值使用 `Option<T>`。
- 提供有意义的错误信息和上下文。
- 错误类型应具有意义且行为良好（实现标准特质）。
- 验证函数参数并为无效输入返回适当的错误。

## API设计指南

### 常用特质实现
在适当的情况下积极实现常用特质：
- `Copy`、`Clone`、`Eq`、`PartialEq`、`Ord`、`PartialOrd`、`Hash`、`Debug`、`Display`、`Default`
- 使用标准转换特质：`From`、`AsRef`、`AsMut`
- 集合应实现 `FromIterator` 和 `Extend`
- 注意：`Send` 和 `Sync` 在安全的情况下由编译器自动实现，除非使用 `unsafe` 代码，否则避免手动实现

### 类型安全和可预测性
- 使用新类型（newtypes）提供静态区分
- 参数应通过类型传达含义；优先使用具体类型而非通用 `bool` 参数
- 适当使用 `Option<T>` 表示真正可选的值
- 具有明确接收者的函数应作为方法实现
- 仅智能指针应实现 `Deref` 和 `DerefMut`

### 未来兼容性
- 使用密封特质（sealed traits）防止下游实现
- 结构体应具有私有字段
- 函数应验证其参数
- 所有公共类型必须实现 `Debug`

## 测试和文档

- 使用 `#[cfg(test)]` 模块和 `#[test]` 注解编写全面的单元测试。
- 在测试代码的代码模块中使用测试模块（`mod tests { ... }`）。
- 在 `tests/` 目录中编写集成测试，使用描述性的文件名。
- 为每个函数、结构体、枚举和复杂逻辑编写清晰简洁的注释。
- 确保函数具有描述性的名称并包含全面的文档。
- 使用 rustdoc (`///` 注释) 文档所有公共API，遵循 [API指南](https://rust-lang.github.io/api-guidelines/)。
- 使用 `#[doc(hidden)]` 隐藏实现细节以避免公共文档暴露。
- 文档错误条件、恐慌场景和安全注意事项。
- 示例应使用 `?` 运算符，而非 `unwrap()` 或已弃用的 `try!` 宏。

## 项目组织

- 在 `Cargo.toml` 中使用语义化版本控制。
- 包含全面的元数据：`description`、`license`、`repository`、`keywords`、`categories`。
- 使用特性标志（feature flags）实现可选功能。
- 使用 `mod.rs` 或命名文件组织代码到模块中。
- 保持 `main.rs` 或 `lib.rs` 简洁，将逻辑移动到模块中。

## 质量检查清单

在发布或审查Rust代码前，请确保：

### 核心要求
- [ ] **命名**：遵循RFC 430命名规范
- [ ] **特质**：在适当情况下实现 `Debug`、`Clone`、`PartialEq`
- [ ] **错误处理**：使用 `Result<T, E>` 并提供有意义的错误类型
- [ ] **文档**：所有公共项都有rustdoc注释并包含示例
- [ ] **测试**：全面的测试覆盖率，包括边界情况

### 安全性和质量
- [ ] **安全性**：无不必要的 `unsafe` 代码，正确的错误处理
- [ ] **性能**：高效使用迭代器，最小化内存分配
- [ ] **API设计**：函数可预测、灵活且类型安全
- [ ] **未来兼容性**：结构体中的私有字段，适当使用密封特质
- [ ] **工具链**：代码通过 `cargo fmt`、`cargo clippy` 和 `cargo test`